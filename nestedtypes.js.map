{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 50dde5fd5e73a273d7d8","webpack:///./src/main.js","webpack:///./src/model.js","webpack:///./src/backbone+.js","webpack:///./src/object+.js","webpack:///./src/backbone.js","webpack:///external {\"commonjs\":\"underscore\",\"commonjs2\":\"underscore\",\"amd\":\"underscore\",\"root\":\"_\"}","webpack:///external {\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\",\"root\":\"$\"}","webpack:///./src/events-mixin.js","webpack:///./src/modelset.js","webpack:///./src/errors.js","webpack:///./src/attribute.js","webpack:///./src/validation-mixin.js","webpack:///./src/rest-mixin.js","webpack:///./src/underscore-mixin.js","webpack:///./src/collection.js","webpack:///./src/collections/commons.js","webpack:///./src/collections/add.js","webpack:///./src/collections/remove.js","webpack:///./src/relations.js","webpack:///./src/metatypes.js","webpack:///./src/store.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B,gBAAgB;AAC3C,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,0BAAyB,0BAA0B,EAAE;AACrD,iCAAgC,2BAA2B;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,mBAAmB,EAAE;AAC9C,iCAAgC,6BAA6B;AAC7D;AACA,EAAC,G;;;;;;ACzED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;;AAEA,qBAAoB,oBAAoB,oBAAoB,4BAA4B;;AAExF,gCAA+B,gBAAgB,EAAE;AACjD;;AAEA;AACA;AACA,sBAAqB;;AAErB,wCAAuC,4CAA4C,EAAE;;AAErF,2CAA0C,qCAAqC,EAAE;;AAEjF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAqC;AACrC;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA,yCAAwC,gBAAgB;AACxD;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gEAA+D;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA,yCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,oCAAmC,qBAAqB,EAAE;;AAE1D;AACA;AACA;AACA,MAAK;;AAEL;AACA,4BAA2B,qBAAqB,cAAc,GAAG,EAAE;;AAEnE;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL,+BAA8B,4BAA4B,EAAE;AAC5D;;AAEA;AACA,EAAC;AACD;AACA,kCAAiC,sBAAsB,mBAAmB,GAAG,EAAE;;AAE/E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D,4CAA4C;AACtG;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA8B;AAC9B;AACA,wEAAuE;;AAEvE;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gFAA+E;AAC/E;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAwC;;AAExC;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;;AAEA;AACA;AACA;AACA;;AAEA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,mDAAkD;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2HAA0H;AAC1H;AACA;AACA;;AAEA,gCAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kGAAiG;AACjG,wDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAmC;;AAEnC;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;AChhBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA,0C;;;;;;ACxBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,4DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,mCAAkC;;AAElC;AACA,qFAAoF;AACpF;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA,gEAA+D;AAC/D;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,mCAAkC;;AAElC;AACA,8GAA6G;AAC7G;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,uBAAsB,cAAc;AACpC;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAuG;AACvG,kDAAiD,EAAE;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,wCAAwC;AACvF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wDAAuD,aAAa;;AAEpE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA2B;;AAE3B,4CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAA+B,GAAG;AAClC;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gDAA+C;;AAE/C;AACA,qCAAoC;;AAEpC;;AAEA;AACA;;AAEA;AACA,4BAA2B,sBAAsB;AACjD;;AAEA;AACA;AACA,wFAAuF;AACvF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL,EAAC;;AAED,sC;;;;;;iEChPA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,IAAG;AACH;AACA,UAAS,uBAAuB,EAAE;AAClC;;AAEA;AACA,IAAG;AACH,qCAAoC;AACpC;;AAEA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gDAA+C,YAAY,YAAY;AACvE,MAAK;;AAEL;AACA;AACA;AACA;AACA,yCAAwC,YAAY,YAAY;AAChE,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA,uCAAsC,8BAA8B,EAAE;AACtE,MAAK;;AAEL;AACA;AACA,wCAAuC,gBAAgB;AACvD,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,wCAAuC,MAAM;AAC7C,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,UAAS,6BAA6B;AACtC;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,0CAAyC,cAAc;AACvD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,8BAA6B,iCAAiC;AAC9D,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;;AAEnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,wEAAuE;;AAEvE;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;;AAEA;;AAEA,EAAC;;;;;;;;AC9uBD,gD;;;;;;ACAA,gD;;;;;;ACAA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,2DAA2D;AAC7E,sDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA;;AAEA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA;;AAEA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA;;AAEA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,uCAAsC,mBAAmB,EAAE;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA,mCAAkC,mBAAmB;AACrD;AACA;AACA,MAAK;AACL;AACA,gDAA+C,kBAAkB;AACjE;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAoD;AACpD;AACA;AACA;AACA,MAAK;;AAEL;AACA,+DAA8D;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,kFAAkF;AACzG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAmB,gBAAgB;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAU,kBAAkB;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B,YAAY;AAC1C,uCAAsC;AACtC;AACA;;AAEA;AACA;AACA,+BAA8B,YAAY;AAC1C,uCAAsC;AACtC;AACA;;AAEA,gDAA+C,mBAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,YAAY;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAuE;AACvE,4EAA2E;AAC3E,gFAA+E;AAC/E,oFAAmF;AACnF,gFAA+E;AAC/E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yB;;;;;;ACrWA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAsB;AACtB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAqD;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;ACrPA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAsE;AACtE,MAAK;;AAEL;AACA,mHAAkH;AAClH,MAAK;;AAEL;AACA;;AAEA;AACA,wFAAuF;AACvF,MAAK;;AAEL;AACA;;AAEA;AACA,wFAAuF;AACvF,MAAK;;AAEL;AACA;AACA;AACA,uEAAsE;AACtE,MAAK;;AAEL;AACA;AACA,oEAAmE;AACnE;AACA,EAAC;;AAED;;;;;;;AC3CA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;;AAEjB;;AAEA;AACA,0BAAyB,aAAa;AACtC,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA,4DAA2D,qBAAqB,IAAI;AACpF;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,yEAAwE;AACxE;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAuB;;AAEvB;AACA,0BAAyB;;AAEzB;AACA;AACA,kCAAiC,wBAAwB,EAAE;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL,gDAA+C;;AAE/C;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,yCAAwC,0CAA0C,EAAE;;AAEpF;AACA,wCAAuC,wDAAwD,EAAE;AACjG,kCAAiC,gCAAgC;AACjE;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA2B,iBAAiB;AAC5C;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,oCAAmC,cAAc,EAAE;;AAEnD;AACA;AACA;;AAEA,6CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;;AAEA;AACA,kCAAiC,6BAA6B;AAC9D;;AAEA;AACA,4BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,6CAA4C,mBAAmB;AAC/D,kBAAiB;AACjB;AACA;AACA,MAAK;AACL,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC,wBAAwB;AACxD;;AAEA;AACA;;AAEA;;;;;;;ACpbA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA,4BAA2B;;AAE3B;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,8DAA6D,0BAA0B;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA2D;;AAE3D;AACA;AACA;;AAEA;AACA;;AAEA;AACA,G;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAgC,oBAAoB,EAAE;AACtD,MAAK;;AAEL;AACA;AACA;AACA;AACA,6CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;;AAEA,+BAA8B,gCAAgC;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;;;AAGjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAAyC,WAAW;AACpD,2DAA0D;;AAE1D;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA,MAAK;;AAEL;AACA,mBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA4C,sBAAsB;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,G;;;;;;ACrSA;;AAEA;;AAEA;AACA,0BAAyB,gDAAgD,EAAE;;AAE3E;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,uCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAkE,MAAM;AACxE;AACA;AACA;AACA,uDAAsD,4BAA4B;AAClF;AACA;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB;;AAErB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA,wBAAuB,mBAAmB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA,2BAA0B,eAAe;;AAEzC;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,6CAA4C;AAC5C;;AAEA;;AAEA,uEAAsE,kCAAkC;;AAExG;AACA,MAAK;;AAEL;AACA;AACA,0CAAyC,kBAAkB;AAC3D,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL,4BAA2B,qBAAqB,cAAc,GAAG,EAAE;;AAEnE;AACA;AACA;AACA;AACA,uBAAsB;;AAEtB,+CAA8C,mDAAmD;AACjG,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL,8BAA6B,qCAAqC,EAAE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA,8CAA6C,mBAAmB;AAChE,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,G;;;;;;ACxTD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAe;;AAEf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,E;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,oBAAoB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0DAAyD,SAAS;AAClE;AACA;;AAEA,wBAAuB,kBAAkB;AACzC;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB;AACxB;;AAEA,2BAA0B,SAAS;AACnC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAmB;;AAEnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,mBAAmB;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,E;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA0B,iBAAiB;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA,E;;;;;;AC9GA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mCAAkC,cAAc,EAAE;AAClD,kCAAiC,gBAAgB,EAAE;AACnD;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iFAAgF;AAChF;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL,qCAAoC,eAAe;AACnD,2CAA0C;AAC1C;AACA;;AAEA;;AAEA;AACA,mBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,8BAA6B,kDAAkD,EAAE;;AAEjF;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,yCAAwC,gBAAgB;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA,MAAK;AACL;;;;;;;ACvOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,4BAA2B,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,aAAa,EAAE,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,uBAAuB,EAAE,SAAS,EAAE;;AAEhJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA0B,0BAA0B;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL,gCAA+B,gCAAgC,EAAE;;AAEjE,kCAAiC,oCAAoC,EAAE;AACvE,mCAAkC,oCAAoC;AACtE,EAAC;;AAED;AACA;AACA;AACA;AACA,yBAAwB,gCAAgC;;AAExD;AACA,yBAAwB,oBAAoB,EAAE;;AAE9C,gCAA+B,cAAc,EAAE;AAC/C,gCAA+B,kDAAkD,EAAE;;AAEnF,kCAAiC,gBAAgB,EAAE;;AAEnD,+BAA8B,cAAc;AAC5C,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,gCAA+B,cAAc,EAAE;AAC/C;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA,4BAA2B,aAAa;AACxC,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,yCAAwC,wCAAwC,EAAE;AAClF;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL,kCAAiC,gBAAgB,EAAE;;AAEnD;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB,4CAA2C,wDAAwD,EAAE;AACrG,sCAAqC,gCAAgC;AACrE;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,6CAA4C;AAC5C,gEAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;AC5ND;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,yBAAwB,aAAa,EAAE;;AAEvC,qBAAoB,oDAAoD,EAAE;AAC1E;AACA,0BAAyB,qFAAqF;AAC9G,EAAC;;AAED;AACA,oBAAmB;;AAEnB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA,EAAC;;AAED;AACA;AACA,sBAAqB,eAAe,EAAE;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"./nestedtypes.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"underscore\", \"jquery\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Nested\"] = factory(require(\"underscore\"), require(\"jquery\"));\n\telse\n\t\troot[\"Nested\"] = factory(root[\"_\"], root[\"$\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 50dde5fd5e73a273d7d8\n **/","// NestedTypes namespace\r\n// =======================\r\n\r\nvar Model      = require( './model' ),\r\n    Collection = require( './collection' ),\r\n    relations  = require( './relations' ),\r\n    Backbone   = require( './backbone+' ),\r\n    _          = require( 'underscore' ),\r\n    attribute  = require( './attribute' ),\r\n    Rest       = require( './rest-mixin' );\r\n\r\nRest.$ = Backbone.$;\r\n\r\nrequire( './metatypes' );\r\n\r\nCollection.subsetOf = relations.subsetOf;\r\nModel.from          = relations.from;\r\nModel.take          = Collection.take = relations.take;\r\n\r\nModel.Collection = Collection;\r\n\r\nvar Store = require( './store' );\r\nObject.defineProperty( exports, 'store', Store.globalProp );\r\n\r\nexports.store = new Store.Model();\r\n\r\n_.extend( exports, Backbone, {\r\n    Backbone  : Backbone,\r\n    Class     : require( './object+' ),\r\n    error     : require( './errors' ),\r\n    attribute : attribute,\r\n    options   : attribute,\r\n\r\n    value : function( value ){\r\n        return attribute( { value : value } );\r\n    },\r\n\r\n    parseReference : relations.parseReference,\r\n\r\n    Collection : Collection,\r\n    Model      : Model,\r\n    Store      : Store.Model,\r\n    LazyStore  : Store.Lazy,\r\n\r\n    defaults : function( x ){\r\n        return Model.defaults( x );\r\n    },\r\n\r\n    transaction : function( fun ){\r\n        return function(){\r\n            return this.transaction( fun, this, arguments );\r\n        }\r\n    }\r\n} );\r\n\r\nfunction linkProperty( Namespace, name ){\r\n    return {\r\n        get : function(){ return Namespace[ name ]; },\r\n        set : function( value ){ Namespace[ name ] = value; }\r\n    };\r\n}\r\n\r\n// allow sync and jQuery override\r\nObject.defineProperties( exports, {\r\n    'sync'         : linkProperty( Rest, 'sync' ),\r\n    'errorPromise' : linkProperty( Rest, 'errorPromise' ),\r\n    'ajax'         : linkProperty( Rest, 'ajax' ),\r\n    'history'      : linkProperty( Backbone, 'history' ),\r\n\r\n    '$' : {\r\n        get : function(){ return Backbone.$; },\r\n        set : function( value ){ Backbone.$ = Rest.$ = value; }\r\n    }\r\n} );\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","var Backbone        = require( './backbone+' ),\r\n    BaseModel       = Backbone.Model,\r\n    modelSet        = require( './modelset' ),\r\n    attrOptions     = require( './attribute' ),\r\n    error           = require( './errors' ),\r\n    _               = require( 'underscore' ),\r\n    ValidationMixin = require( './validation-mixin' ),\r\n    RestMixin       = require( './rest-mixin' ).Model,\r\n    UnderscoreMixin = require( './underscore-mixin' );\r\n\r\nvar setSingleAttr  = modelSet.setSingleAttr,\r\n    setAttrs       = modelSet.setAttrs,\r\n    applyTransform = modelSet.transform;\r\n\r\nfunction deepCloneAttrs( model, a_attrs ){\r\n    var attrs     = new model.Attributes( a_attrs ),\r\n        attrSpecs = model.__attributes,\r\n        options   = { deep : true };\r\n\r\n    model.forEachAttr( attrs, function( value, name ){\r\n        attrs[ name ] = attrSpecs[ name ].clone( value, options );\r\n    } );\r\n\r\n    return attrs;\r\n}\r\n\r\nvar _cidCount = 1;\r\n\r\nvar Model = BaseModel.extend( {\r\n    mixins             : [ ValidationMixin, RestMixin, UnderscoreMixin.Model ],\r\n    triggerWhenChanged : 'change',\r\n\r\n    properties : {\r\n        _clonedProps : {\r\n            enumerable : false,\r\n            get        : function(){\r\n                var props = {};\r\n\r\n                this.forEachProp( this, function( value, name ){\r\n                    props[ name ] = value;\r\n                } );\r\n\r\n                return props;\r\n            }\r\n        },\r\n\r\n        id : {\r\n            get : function(){\r\n                var name = this.idAttribute;\r\n\r\n                // TODO: get hook doesn't work for idAttribute === 'id'\r\n                return name === 'id' ? this.attributes.id : this[ name ];\r\n            },\r\n\r\n            set : function( value ){\r\n                var name = this.idAttribute;\r\n                setSingleAttr( this, name, value, this.__attributes[ name ] );\r\n            }\r\n        },\r\n\r\n        changed : {\r\n            enumerable : false,\r\n            get        : function(){\r\n                var changed = this._changed;\r\n\r\n                if( !changed ){\r\n                    var last = this.attributes,\r\n                        prev = this._previousAttributes;\r\n\r\n                    changed = {};\r\n\r\n                    this.forEachAttr( this.__attributes, function( attrSpec, name ){\r\n                        if( attrSpec.isChanged( last[ name ], prev[ name ] ) ){\r\n                            changed[ name ] = last[ name ];\r\n                        }\r\n                    } );\r\n\r\n                    this._changed = changed;\r\n                }\r\n\r\n                return changed;\r\n            }\r\n        }\r\n    },\r\n\r\n    _validateNested : function( errors ){\r\n        var attrSpecs = this.__attributes,\r\n            length    = 0,\r\n            model     = this;\r\n\r\n        this.forEachAttr( this.attributes, function( value, name ){\r\n            var error = attrSpecs[ name ].validate( model, value, name );\r\n\r\n            if( error ){\r\n                errors[ name ] = error;\r\n                length++;\r\n            }\r\n        } );\r\n\r\n        return length;\r\n    },\r\n\r\n    getStore : function(){\r\n        var owner = this._owner || this.collection;\r\n        return owner ? owner.getStore() : this._defaultStore;\r\n    },\r\n\r\n    getOwner : function(){\r\n        return this._owner || ( this.collection && this.collection._owner );\r\n    },\r\n\r\n    sync : function(){\r\n        var store = this.getStore() || Backbone;\r\n        return store.sync.apply( this, arguments );\r\n    },\r\n\r\n    _owner : null,\r\n\r\n    __attributes : { id : attrOptions( { value : undefined } ).createAttribute( 'id' ) },\r\n\r\n    Attributes : function( x ){ this.id = x.id; },\r\n    __class    : 'Model',\r\n\r\n    __duringSet  : 0,\r\n    _changed     : null,\r\n    _changeToken : {},\r\n\r\n    forEachAttr : function( obj, fun ){ this.id === void 0 || fun( this.id, 'id' ); },\r\n\r\n    defaults : function( attrs, options ){ return new this.Attributes( attrs ); },\r\n\r\n    __begin  : modelSet.__begin,\r\n    __commit : modelSet.__commit,\r\n\r\n    transaction : modelSet.transaction,\r\n\r\n    // Determine if the model has changed since the last `\"change\"` event.\r\n    // If you specify an attribute name, determine if that attribute has changed.\r\n    hasChanged : function( attr ){\r\n        if( attr == null ) return !_.isEmpty( this.changed );\r\n        return this.__attributes[ attr ].isChanged( this.attributes[ attr ], this._previousAttributes[ attr ] );\r\n    },\r\n\r\n    // Return an object containing all the attributes that have changed, or\r\n    // false if there are no changed attributes. Useful for determining what\r\n    // parts of a view need to be updated and/or what attributes need to be\r\n    // persisted to the server. Unset attributes will be set to undefined.\r\n    // You can also pass an attributes object to diff against the model,\r\n    // determining if there *would be* a change.\r\n    // TODO: Test it\r\n    changedAttributes : function( diff ){\r\n        if( !diff ) return this.hasChanged() ? _.clone( this.changed ) : false;\r\n\r\n        var val, changed = false,\r\n            old          = this._changing ? this._previousAttributes : this.attributes,\r\n            attrSpecs    = this.__attributes;\r\n\r\n        for( var attr in diff ){\r\n            if( !attrSpecs[ attr ].isChanged( old[ attr ], ( val = diff[ attr ] ) ) ) continue;\r\n            (changed || (changed = {}))[ attr ] = val;\r\n        }\r\n\r\n        return changed;\r\n    },\r\n\r\n    // Get all of the attributes of the model at the time of the previous\r\n    // `\"change\"` event.\r\n    previousAttributes : function(){\r\n        return new this.Attributes( this._previousAttributes );\r\n    },\r\n\r\n    set : function( a, b, c ){\r\n        switch( typeof a ){\r\n            case 'string' :\r\n                var attrSpec = this.__attributes[ a ];\r\n\r\n                if( attrSpec && !attrSpec.isBackboneType && !c ){\r\n                    return setSingleAttr( this, a, b, attrSpec );\r\n                }\r\n\r\n                var attrs  = {};\r\n                attrs[ a ] = b;\r\n                return setAttrs( this, attrs, c );\r\n\r\n            case 'object' :\r\n                if( a && Object.getPrototypeOf( a ) === Object.prototype ){\r\n                    return setAttrs( this, a, b );\r\n                }\r\n\r\n            default :\r\n                error.argumentIsNotAnObject( this, a );\r\n        }\r\n    },\r\n\r\n    // Return model's value for dot-separated 'deep reference'.\r\n    // Model id and cid are allowed for collection elements.\r\n    // If path is not exist, 'undefined' is returned.\r\n    // model.deepGet( 'a.b.c123.x' )\r\n    deepGet : function( path ){\r\n        return this._deepGet( path.split( '.' ) );\r\n    },\r\n\r\n    deepValidationError : function( name ){\r\n        var path  = name.split( '.' ),\r\n            attr  = path.pop(),\r\n            model = this._deepGet( path ) || null;\r\n\r\n        return model && model.getValidationError( attr );\r\n    },\r\n\r\n    _deepGet : function( path ){\r\n        var value = this;\r\n\r\n        for( var i = 0, l = path.length; value && i < l; i++ ){\r\n            value = value.get ? value.get( path[ i ] ) : value[ path[ i ] ];\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    // Set model's value for dot separated 'deep reference'.\r\n    // If model doesn't exist at some path, create default models\r\n    // if options.nullify is given, assign attributes with nulls\r\n    deepSet : function( name, value, options ){\r\n        var path  = name.split( '.' ),\r\n            l     = path.length - 1,\r\n            model = this,\r\n            attr  = path[ l ];\r\n\r\n        for( var i = 0; i < l; i++ ){\r\n            var current = path[ i ],\r\n                next    = model.get ? model.get( current ) : model[ current ];\r\n\r\n            // Create models in path, if they are not exist.\r\n            if( !next ){\r\n                var attrSpecs = model.__attributes;\r\n\r\n                if( attrSpecs ){\r\n                    // If current object is model, create default attribute\r\n                    var newModel = attrSpecs[ current ].create( null, options );\r\n\r\n                    // If created object is model, nullify attributes when requested\r\n                    if( options && options.nullify && newModel.__attributes ){\r\n                        var nulls = new newModel.Attributes( {} );\r\n                        for( var key in nulls ){\r\n                            nulls[ key ] = null;\r\n                        }\r\n                        newModel.set( nulls );\r\n                    }\r\n\r\n                    model[ current ] = next = newModel;\r\n                }\r\n                else{\r\n                    return;\r\n                } // silently fail in other case\r\n            }\r\n            model = next;\r\n        }\r\n\r\n        return model.set ? model.set( attr, value, options ) : model[ attr ] = value;\r\n    },\r\n\r\n    cidPrefix : 'c',\r\n\r\n    constructor : function( attributes, opts ){\r\n        var attrSpecs = this.__attributes,\r\n            attrs     = attributes || {},\r\n            options   = opts || {};\r\n\r\n        this.__duringSet = 0;\r\n        this._changing   = this._pending = false;\r\n        this._changeToken = {};\r\n        this.attributes   = {};\r\n        this.cid          = this.cidPrefix + _cidCount++;\r\n\r\n        if( options.parse ){\r\n            attrs = this.parse( attrs, options ) || {};\r\n        }\r\n\r\n        //  Make this.collection accessible in initialize\r\n        if( options.collection ){\r\n            this.collection = options.collection;\r\n\r\n            // do not pass it to nested objects.\r\n            // No side effect here, options copied at the upper level in this case\r\n            options.collection = null;\r\n        }\r\n\r\n        if( typeof attrs !== 'object' || Object.getPrototypeOf( attrs ) !== Object.prototype ){\r\n            error.argumentIsNotAnObject( this, attrs );\r\n            attrs = {};\r\n        }\r\n\r\n        attrs = options.deep ? deepCloneAttrs( this, attrs ) : this.defaults( attrs );\r\n\r\n        // Execute attributes transform function instead of this.set\r\n        applyTransform( this, attrs, attrSpecs, options );\r\n\r\n        this._previousAttributes = this.attributes = attrs;\r\n        this.initialize.apply( this, arguments );\r\n    },\r\n    // override get to invoke native getter...\r\n    get         : function( name ){ return this[ name ]; },\r\n\r\n    // override clone to pass options to constructor\r\n    clone : function( options ){\r\n        return new this.constructor( this.attributes, options );\r\n    },\r\n\r\n    // Create deep copy for all nested objects...\r\n    deepClone : function(){ return this.clone( { deep : true } ); },\r\n\r\n    // Support for nested models and objects.\r\n    // Apply toJSON recursively to produce correct JSON.\r\n    toJSON : function(){\r\n        var self      = this,\r\n            res       = {},\r\n            attrSpecs = this.__attributes;\r\n\r\n        this.forEachAttr( this.attributes, function( value, key ){\r\n            var attrSpec = attrSpecs[ key ],\r\n                toJSON   = attrSpec && attrSpec.toJSON;\r\n\r\n            if( toJSON ){\r\n                res[ key ] = toJSON.call( self, value, key );\r\n            }\r\n        } );\r\n\r\n        return res;\r\n    },\r\n\r\n    parse  : function( resp ){ return this._parse( resp ); },\r\n    _parse : _.identity,\r\n\r\n    _ : _ // add underscore to be accessible in templates\r\n}, {\r\n    // shorthand for inline nested model definitions\r\n    defaults : function( attrs ){ return this.extend( { defaults : attrs } ); },\r\n\r\n    // extend Model and its Collection\r\n    extend : function( protoProps, staticProps ){\r\n        var Child;\r\n\r\n        if( typeof protoProps === 'function' ){\r\n            Child      = protoProps;\r\n            protoProps = null;\r\n        }\r\n        else if( protoProps && protoProps.hasOwnProperty( 'constructor' ) ){\r\n            Child = protoProps.constructor;\r\n        }\r\n        else{\r\n            var Parent = this;\r\n            Child      = function Model( attrs, options ){ return Parent.call( this, attrs, options ); };\r\n        }\r\n\r\n        var This        = Object.extend.call( this, Child );\r\n        This.Collection = this.Collection.extend();\r\n        return protoProps ? This.define( protoProps, staticProps ) : This;\r\n    },\r\n\r\n    // define Model and its Collection. All the magic starts here.\r\n    define : function( protoProps, staticProps ){\r\n        var Base = Object.getPrototypeOf( this.prototype ).constructor,\r\n            spec = createDefinition( protoProps, Base ),\r\n            This = this;\r\n\r\n        Object.extend.Class.define.call( This, spec, staticProps );\r\n        attachMixins( This );\r\n\r\n        // define Collection\r\n        var collectionSpec = { model : This };\r\n        spec.urlRoot && ( collectionSpec.url = spec.urlRoot );\r\n        This.Collection.define( _.defaults( protoProps.collection || {}, collectionSpec ) );\r\n\r\n        return This;\r\n    }\r\n} );\r\n\r\nfunction attachMixins( Type ){\r\n    var self      = Type.prototype,\r\n        attrSpecs = self.__attributes;\r\n\r\n    for( name in attrSpecs ){\r\n        attrSpecs[ name ].attachMixins( self );\r\n    }\r\n}\r\n\r\n// Create model definition from protoProps spec.\r\nfunction createDefinition( protoProps, Base ){\r\n    var defaults           = protoProps.defaults || protoProps.attributes || {},\r\n        defaultsAsFunction = typeof defaults == 'function' && defaults,\r\n        baseAttrSpecs      = Base.prototype.__attributes;\r\n\r\n    // Support for legacy backbone defaults as functions.\r\n    if( defaultsAsFunction ){\r\n        defaults = defaults();\r\n    }\r\n\r\n    var attrSpecs = Object.transform( {}, defaults, attrOptions.create );\r\n\r\n    // Create attribute for idAttribute, if it's not declared explicitly\r\n    var idAttribute = protoProps.idAttribute;\r\n    if( idAttribute && !attrSpecs[ idAttribute ] ){\r\n        attrSpecs[ idAttribute ] = attrOptions( { value : undefined } ).createAttribute( idAttribute );\r\n    }\r\n\r\n    // Prevent conflict with backbone model's 'id' property\r\n    if( attrSpecs[ 'id' ] ){\r\n        attrSpecs[ 'id' ].createPropertySpec = false;\r\n    }\r\n\r\n    var allAttrSpecs = _.defaults( {}, attrSpecs, baseAttrSpecs ),\r\n        Attributes   = Object.createCloneCtor( allAttrSpecs );\r\n\r\n    return _.extend( _.omit( protoProps, 'collection', 'attributes' ), {\r\n        __attributes : new Attributes( allAttrSpecs ),\r\n        forEachAttr  : Object.createForEach( allAttrSpecs ),\r\n        _parse       : createParse( allAttrSpecs, attrSpecs ) || Base.prototype._parse,\r\n        defaults     : defaultsAsFunction || createDefaults( allAttrSpecs ),\r\n        properties   : createAttrsNativeProps( protoProps.properties, attrSpecs ),\r\n        Attributes   : Attributes\r\n    } );\r\n}\r\n\r\n// Create attributes 'parse' option function only if local 'parse' options present.\r\n// Otherwise return null.\r\nfunction createParse( allAttrSpecs, attrSpecs ){\r\n    var statements = [ 'var a = this.__attributes;' ],\r\n        create     = false;\r\n\r\n    for( var name in allAttrSpecs ){\r\n        // Is there any 'parse' option in local model definition?\r\n        if( attrSpecs[ name ] && attrSpecs[ name ].parse ) create = true;\r\n\r\n        // Add statement for each attribute with 'parse' option.\r\n        if( allAttrSpecs[ name ].parse ){\r\n            var s = 'if(\"' + name + '\" in r) r.' + name + '=a.' + name + '.parse.call(this,r.' + name + ',\"' + name + '\");';\r\n            statements.push( s );\r\n        }\r\n    }\r\n\r\n    statements.push( 'return r;' );\r\n\r\n    return create ? new Function( 'r', statements.join( '' ) ) : null;\r\n}\r\n\r\n// Check if value is valid JSON.\r\nfunction isValidJSON( value ){\r\n    if( value === null ){\r\n        return true;\r\n    }\r\n\r\n    switch( typeof value ){\r\n        case 'number' :\r\n        case 'string' :\r\n        case 'boolean' :\r\n            return true;\r\n\r\n        case 'object':\r\n            var proto = Object.getPrototypeOf( value );\r\n\r\n            if( proto === Object.prototype || proto === Array.prototype ){\r\n                return _.every( value, isValidJSON );\r\n            }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Create optimized model.defaults( attrs, options ) function\r\nfunction createDefaults( attrSpecs ){\r\n    var assign_f = [], create_f = [];\r\n\r\n    function appendExpr( name, expr ){\r\n        assign_f.push( 'this.' + name + '=a.' + name + '===undefined?' + expr + ':a.' + name + ';' );\r\n        create_f.push( 'this.' + name + '=' + expr + ';' );\r\n    }\r\n\r\n    // Compile optimized constructor function for efficient deep copy of JSON literals in defaults.\r\n    _.each( attrSpecs, function( attrSpec, name ){\r\n        if( attrSpec.value === undefined && attrSpec.type ){\r\n            // if type with no value is given, create an empty object\r\n            appendExpr( name, 'i.' + name + '.create()' );\r\n        }\r\n        else{\r\n            // If value is given, type casting logic will do the job later, converting value to the proper type.\r\n            if( isValidJSON( attrSpec.value ) ){\r\n                // JSON literals must be deep copied.\r\n                appendExpr( name, JSON.stringify( attrSpec.value ) );\r\n            }\r\n            else if( attrSpec.value === undefined ){\r\n                // handle undefined value separately. Usual case for model ids.\r\n                appendExpr( name, 'undefined' );\r\n            }\r\n            else{\r\n                // otherwise, copy value by reference.\r\n                appendExpr( name, 'i.' + name + '.value' );\r\n            }\r\n        }\r\n    } );\r\n\r\n    var CreateDefaults = new Function( 'i', create_f.join( '' ) ),\r\n        AssignDefaults = new Function( 'a', 'i', assign_f.join( '' ) );\r\n\r\n    CreateDefaults.prototype = AssignDefaults.prototype = Object.prototype;\r\n\r\n    // Create model.defaults( attrs, options ) function\r\n    // 'attrs' will override default values, options will be passed to nested backbone types\r\n    return function( attrs ){\r\n        return attrs ? new AssignDefaults( attrs || {}, this.__attributes ) : new CreateDefaults( this.__attributes );\r\n    }\r\n}\r\n\r\n// Create native properties for model's attributes\r\nfunction createAttrsNativeProps( properties, attrSpecs ){\r\n    if( properties === false ){\r\n        return {};\r\n    }\r\n\r\n    properties || ( properties = {} );\r\n\r\n    return Object.transform( properties, attrSpecs, function( attrSpec, name ){\r\n        if( !properties[ name ] && attrSpec.createPropertySpec ){\r\n            return attrSpec.createPropertySpec();\r\n        }\r\n    } );\r\n}\r\n\r\nmodule.exports = Model;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/model.js\n ** module id = 1\n ** module chunks = 0\n **/","/* Backbone core extensions: bug fixes and optimizations\r\n    - Use Object+ for all backbone objects\r\n    - Fix for Events.listenTo to support message maps\r\n    - optimized trigger functions\r\n\r\n * (c) Vlad Balin & Volicon, 2015\r\n * ------------------------------------------------------------- */\r\n\r\nvar Class = require( './object+' ),\r\n    Backbone = require( './backbone' ),\r\n    Events = require( './events-mixin' );\r\n\r\nBackbone.Events = Events;\r\nObject.assign( Backbone, Events );\r\nmodule.exports = Backbone;\r\n\r\n// Update Backbone objects to use event patches and Object+\r\n[ 'Model', 'Collection', 'View', 'Router', 'History' ].forEach( function( name ){\r\n    var Type = Backbone[ name ];\r\n    Object.assign( Type.prototype, Events );\r\n    Object.extend.attach( Type );\r\n});\r\n\r\n// Make Object.extend classes capable of sending and receiving Backbone Events...\r\nObject.assign( Class.prototype, Events );\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/backbone+.js\n ** module id = 2\n ** module chunks = 0\n **/","/* Object extensions: backbone-style OO functions and helpers...\r\n * (c) Vlad Balin & Volicon, 2015\r\n * ------------------------------------------------------------- */\r\n\r\n(function( spec ){\r\n    for( var name in spec ){\r\n        Object[ name ] || Object.defineProperty( Object, name, {\r\n            enumerable   : false,\r\n            configurable : true,\r\n            writable     : true,\r\n            value        : spec[ name ]\r\n        } );\r\n    }\r\n})( {\r\n    // Object.assign polyfill from MDN.\r\n    assign : function( target, firstSource ){\r\n        if( target == null ){\r\n            throw new TypeError( 'Cannot convert first argument to object' );\r\n        }\r\n\r\n        var to = Object( target );\r\n        for( var i = 1; i < arguments.length; i++ ){\r\n            var nextSource = arguments[ i ];\r\n            if( nextSource == null ){\r\n                continue;\r\n            }\r\n\r\n            var keysArray = Object.keys( Object( nextSource ) );\r\n            for( var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++ ){\r\n                var nextKey = keysArray[ nextIndex ];\r\n                var desc    = Object.getOwnPropertyDescriptor( nextSource, nextKey );\r\n                if( desc !== void 0 && desc.enumerable ){\r\n                    to[ nextKey ] = nextSource[ nextKey ];\r\n                }\r\n            }\r\n        }\r\n        return to;\r\n    },\r\n\r\n    createForEach : function( attrSpecs ){\r\n        var statements = [ 'var v;' ];\r\n\r\n        for( var name in attrSpecs ){\r\n            statements.push( '(v=a.' + name + ')' + '===void 0||f(v,\"' + name + '\");' );\r\n        }\r\n\r\n        return new Function( 'a', 'f', statements.join( '' ) );\r\n    },\r\n\r\n    createCloneCtor : function ( attrSpecs ){\r\n        var statements = [];\r\n\r\n        for( var name in attrSpecs ){\r\n            statements.push( \"this.\" + name + \"=x.\" + name + \";\" );\r\n        }\r\n\r\n        var CloneCtor = new Function( \"x\", statements.join( '' ) );\r\n        CloneCtor.prototype = Object.prototype;\r\n        return CloneCtor;\r\n    },\r\n\r\n    createTransformCtor : function ( attrSpecs ){\r\n        var statements = [ 'var v;' ];\r\n\r\n        for( var name in attrSpecs ){\r\n            statements.push( 'this.' + name + '=(v=a.' + name + ')' + '===void 0?void 0 :f(v,\"' + name + '\");' );\r\n        }\r\n\r\n        var TransformCtor = new Function( \"a\", 'f', statements.join( '' ) );\r\n        TransformCtor.prototype = Object.prototype;\r\n        return TransformCtor;\r\n    },\r\n\r\n    // Object.transform function, similar to _.mapObject\r\n    transform : function( dest, source, fun, context ){\r\n        for( var name in source ){\r\n            if( source.hasOwnProperty( name ) ){\r\n                var value = fun.call( context, source[ name ], name );\r\n                typeof value === 'undefined' || ( dest[ name ] = value );\r\n            }\r\n        }\r\n\r\n        return dest;\r\n    },\r\n\r\n    // get property descriptor looking through all prototype chain\r\n    getPropertyDescriptor : function( obj, prop ){\r\n        for( var desc; !desc && obj; obj = Object.getPrototypeOf( obj ) ){\r\n            desc = Object.getOwnPropertyDescriptor( obj, prop );\r\n        }\r\n\r\n        return desc;\r\n    },\r\n\r\n    // extend function in the fashion of Backbone, with extended features required by NestedTypes\r\n    // - supports native properties definitions\r\n    // - supports forward declarations\r\n    // - warn in case if base class method is overriden with value. It's popular mistake when working with Backbone.\r\n    extend : (function(){\r\n        var error = {\r\n            overrideMethodWithValue : function( Ctor, name, value ){\r\n                console.warn( '[Type Warning] Base class method overriden with value in Object.extend({ ' + name +\r\n                              ' : ' + value + ' }); Object =', Ctor.prototype );\r\n            }\r\n        };\r\n\r\n        function Class(){\r\n            this.initialize.apply( this, arguments );\r\n        }\r\n\r\n        // Backbone-style extend with native properties and late definition support\r\n        function extend( protoProps, staticProps ){\r\n            var Parent = this === Object ? Class : this,\r\n                Child;\r\n\r\n            if( typeof protoProps === 'function' ){\r\n                Child      = protoProps;\r\n                protoProps = null;\r\n            }\r\n            else if( protoProps && protoProps.hasOwnProperty( 'constructor' ) ){\r\n                Child = protoProps.constructor;\r\n            }\r\n            else{\r\n                Child = function Constructor(){ return Parent.apply( this, arguments ); };\r\n            }\r\n\r\n            Object.assign( Child, Parent );\r\n\r\n            Child.prototype             = Object.create( Parent.prototype );\r\n            Child.prototype.constructor = Child;\r\n            Child.__super__             = Parent.prototype;\r\n\r\n            protoProps && Child.define( protoProps, staticProps );\r\n\r\n            return Child;\r\n        }\r\n\r\n        function warnOnError( value, name ){\r\n            var prop = Object.getPropertyDescriptor( this.prototype, name );\r\n\r\n            if( prop ){\r\n                var baseIsFunction  = typeof prop.value === 'function',\r\n                    valueIsFunction = typeof value === 'function';\r\n\r\n                if( baseIsFunction && !valueIsFunction ){\r\n                    error.overrideMethodWithValue( this, name, prop );\r\n                }\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        function preparePropSpec( spec, name ){\r\n            var prop = Object.getPropertyDescriptor( this.prototype, name );\r\n\r\n            if( prop && typeof prop.value === 'function' ){\r\n                error.overrideMethodWithValue( this, name, prop );\r\n            }\r\n\r\n            var prepared = spec instanceof Function ? { get : spec } : spec;\r\n\r\n            if( prepared.enumerable === void 0 ){\r\n                prepared.enumerable = true;\r\n            }\r\n\r\n            return prepared;\r\n        }\r\n\r\n        function attachMixins( protoProps ){\r\n            var mixins = protoProps.mixins,\r\n                merged = {}, properties = {};\r\n\r\n            for( var i = mixins.length - 1; i >= 0; i-- ){\r\n                var mixin = mixins[ i ];\r\n                Object.assign( properties, mixin.properties );\r\n                Object.assign( merged, mixin );\r\n            }\r\n\r\n            Object.assign( merged, protoProps );\r\n            Object.assign( properties, protoProps.properties );\r\n\r\n            merged.properties = properties;\r\n            return merged;\r\n        }\r\n\r\n        function createForEachProp( proto ){\r\n            var allProps = {};\r\n\r\n            // traverse prototype chain\r\n            for( var p = proto; p; p = Object.getPrototypeOf( p ) ){\r\n                Object.transform( allProps, p.properties, function( spec, name ){\r\n                    if( !allProps[ name ] && spec.enumerable ){\r\n                        return spec;\r\n                    }\r\n                } );\r\n            }\r\n\r\n            return Object.createForEach( allProps );\r\n        }\r\n\r\n        function define( a_protoProps, a_staticProps ){\r\n            var protoProps = a_protoProps || {};\r\n            staticProps    = a_staticProps || {};\r\n\r\n            if( protoProps.mixins ){\r\n                protoProps = attachMixins( protoProps );\r\n            }\r\n\r\n            Object.transform( this.prototype, protoProps, warnOnError, this );\r\n\r\n            // do not inherit abstract class factory!\r\n            if( !staticProps.create ) staticProps.create = null;\r\n            Object.assign( this, staticProps ); // No override check here\r\n\r\n            protoProps && Object.defineProperties( this.prototype,\r\n                Object.transform( {}, protoProps.properties, preparePropSpec, this ) );\r\n\r\n            this.prototype.forEachProp = createForEachProp( this.prototype );\r\n\r\n            return this;\r\n        }\r\n\r\n        extend.attach = function(){\r\n            for( var i = 0; i < arguments.length; i++ ){\r\n                var Ctor = arguments[ i ];\r\n\r\n                Ctor.extend = extend;\r\n                Ctor.define = define;\r\n                Ctor.prototype.initialize || ( Ctor.prototype.initialize = function(){} );\r\n            }\r\n        };\r\n\r\n        extend.attach( Class );\r\n        extend.Class = Class;\r\n        extend.error = error;\r\n\r\n        return extend;\r\n    })()\r\n} );\r\n\r\nmodule.exports = Object.extend.Class;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/object+.js\n ** module id = 3\n ** module chunks = 0\n **/","//     Backbone.js 1.2.3\r\n\r\n//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n//     Backbone may be freely distributed under the MIT license.\r\n\r\n(function(factory) {\r\n  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\r\n  // We use `self` instead of `window` for `WebWorker` support.\r\n  var root = (typeof self == 'object' && self.self == self && self) ||\r\n            (typeof global == 'object' && global.global == global && global);\r\n\r\n  // Set up Backbone appropriately for the environment. Start with AMD.\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {\r\n      // Export global even in AMD case in case this script is loaded with\r\n      // others that may still expect a global Backbone.\r\n      root.Backbone = factory(root, exports, _, $);\r\n    });\r\n\r\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\r\n  } else if (typeof exports !== 'undefined') {\r\n    var _ = require('underscore'), $;\r\n    try { $ = require('jquery'); } catch(e) {}\r\n    factory(root, exports, _, $);\r\n\r\n  // Finally, as a browser global.\r\n  } else {\r\n    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\r\n  }\r\n\r\n}(function(root, Backbone, _, $) {\r\n\r\n  // Initial Setup\r\n  // -------------\r\n\r\n  // Save the previous value of the `Backbone` variable, so that it can be\r\n  // restored later on, if `noConflict` is used.\r\n  var previousBackbone = root.Backbone;\r\n\r\n  // Create a local reference to a common array method we'll want to use later.\r\n\r\n  var slice = Array.prototype.slice;\r\n\r\n  // Current version of the library. Keep in sync with `package.json`.\r\n  Backbone.VERSION = '1.2.3';\r\n\r\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\r\n  // the `$` variable.\r\n  Backbone.$ = $;\r\n\r\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\r\n  // to its previous owner. Returns a reference to this Backbone object.\r\n  Backbone.noConflict = function() {\r\n    root.Backbone = previousBackbone;\r\n    return this;\r\n  };\r\n\r\n  // Backbone.Model\r\n  // --------------\r\n\r\n  // Backbone **Models** are the basic data object in the framework --\r\n  // frequently representing a row in a table in a database on your server.\r\n  // A discrete chunk of data and a bunch of useful, related methods for\r\n  // performing computations and transformations on that data.\r\n\r\n  // Create a new model with the specified attributes. A client id (`cid`)\r\n  // is automatically generated and assigned for you.\r\n  var Model = Backbone.Model = function(attributes, options) {};\r\n\r\n  // Attach all inheritable methods to the Model prototype.\r\n  _.extend(Model.prototype, {\r\n\r\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\r\n    // CouchDB users may want to set this to `\"_id\"`.\r\n    idAttribute: 'id',\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // Returns `true` if the attribute contains a value that is not null\r\n    // or undefined.\r\n    has: function(attr) {\r\n      return this.get(attr) != null;\r\n    },\r\n\r\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\r\n    // if the attribute doesn't exist.\r\n    unset: function(attr, options) {\r\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\r\n    },\r\n\r\n    // Clear all attributes on the model, firing `\"change\"`.\r\n    clear: function(options) {\r\n      var attrs = {};\r\n      for (var key in this.attributes) attrs[key] = void 0;\r\n      return this.set(attrs, _.extend({}, options, {unset: true}));\r\n    },\r\n\r\n    // Get the previous value of an attribute, recorded at the time the last\r\n    // `\"change\"` event was fired.\r\n    previous: function(attr) {\r\n      if (attr == null || !this._previousAttributes) return null;\r\n      return this._previousAttributes[attr];\r\n    },\r\n\r\n    // A model is new if it has never been saved to the server, and lacks an id.\r\n    isNew: function() {\r\n      return !this.has(this.idAttribute);\r\n    }\r\n  });\r\n\r\n  // Backbone.Collection\r\n  // -------------------\r\n\r\n  // If models tend to represent a single row of data, a Backbone Collection is\r\n  // more analagous to a table full of data ... or a small slice or page of that\r\n  // table, or a collection of rows that belong together for a particular reason\r\n  // -- all of the messages in this particular folder, all of the documents\r\n  // belonging to this particular author, and so on. Collections maintain\r\n  // indexes of their models, both in order, and for lookup by `id`.\r\n\r\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\r\n  // If a `comparator` is specified, the Collection will maintain\r\n  // its models in sort order, as they're added and removed.\r\n  var Collection = Backbone.Collection = function(models, options) {};\r\n\r\n  // Define the Collection's inheritable methods.\r\n  _.extend(Collection.prototype, {\r\n\r\n    // The default model for a collection is just a **Backbone.Model**.\r\n    // This should be overridden in most cases.\r\n    model: Model,\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // The JSON representation of a Collection is an array of the\r\n    // models' attributes.\r\n    toJSON: function(options) {\r\n      return this.map(function(model){ return model.toJSON(options); });\r\n    },\r\n\r\n    // Add a model to the end of the collection.\r\n    push: function(model, options) {\r\n      return this.add(model, _.extend({at: this.length}, options));\r\n    },\r\n\r\n    // Remove a model from the end of the collection.\r\n    pop: function(options) {\r\n      var model = this.at(this.length - 1);\r\n      this.remove(model, options);\r\n      return model;\r\n    },\r\n\r\n    // Add a model to the beginning of the collection.\r\n    unshift: function(model, options) {\r\n      return this.add(model, _.extend({at: 0}, options));\r\n    },\r\n\r\n    // Remove a model from the beginning of the collection.\r\n    shift: function(options) {\r\n      var model = this.at(0);\r\n      this.remove(model, options);\r\n      return model;\r\n    },\r\n\r\n    // Slice out a sub-array of models from the collection.\r\n    slice: function() {\r\n      return slice.apply(this.models, arguments);\r\n    },\r\n\r\n    // Return models with matching attributes. Useful for simple cases of\r\n    // `filter`.\r\n    where: function(attrs, first) {\r\n      return this[first ? 'find' : 'filter'](attrs);\r\n    },\r\n\r\n    // Return the first model with matching attributes. Useful for simple cases\r\n    // of `find`.\r\n    findWhere: function(attrs) {\r\n      return this.where(attrs, true);\r\n    },\r\n\r\n    // Force the collection to re-sort itself. You don't need to call this under\r\n    // normal circumstances, as the set will maintain sort order as each item\r\n    // is added.\r\n    sort: function(options) {\r\n      var comparator = this.comparator;\r\n      if (!comparator) throw new Error('Cannot sort a set without a comparator');\r\n      options || (options = {});\r\n\r\n      var length = comparator.length;\r\n      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);\r\n      // Run sort based on type of `comparator`.\r\n      if (length === 1 || _.isString(comparator)) {\r\n        this.models = this.sortBy(comparator);\r\n      } else {\r\n        this.models.sort(comparator);\r\n      }\r\n\r\n      if (!options.silent) this.trigger('sort', this, options);\r\n      return this;\r\n    },\r\n\r\n    // Pluck an attribute from each model in the collection.\r\n    pluck: function(attr) {\r\n      return _.invoke(this.models, 'get', attr);\r\n    },\r\n\r\n    // **parse** converts a response into a list of models to be added to the\r\n    // collection. The default implementation is just to pass it through.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    }\r\n  });\r\n\r\n  // Backbone.View\r\n  // -------------\r\n\r\n  // Backbone Views are almost more convention than they are actual code. A View\r\n  // is simply a JavaScript object that represents a logical chunk of UI in the\r\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\r\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\r\n  // UI as a **View** allows you to define your DOM events declaratively, without\r\n  // having to worry about render order ... and makes it easy for the view to\r\n  // react to specific changes in the state of your models.\r\n\r\n  // Creating a Backbone.View creates its initial element outside of the DOM,\r\n  // if an existing element is not provided...\r\n  var View = Backbone.View = function(options) {\r\n    this.cid = _.uniqueId('view');\r\n    options || (options = {});\r\n    _.extend(this, _.pick(options, viewOptions));\r\n    this._ensureElement();\r\n    this.initialize.apply(this, arguments);\r\n    this.delegateEvents();\r\n  };\r\n\r\n  // Cached regex to split keys for `delegate`.\r\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\r\n\r\n  // List of view options to be merged as properties.\r\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\r\n\r\n  // Set up all inheritable **Backbone.View** properties and methods.\r\n  _.extend(View.prototype, {\r\n\r\n    // The default `tagName` of a View's element is `\"div\"`.\r\n    tagName: 'div',\r\n\r\n    // jQuery delegate for element lookup, scoped to DOM elements within the\r\n    // current view. This should be preferred to global lookups where possible.\r\n    $: function(selector) {\r\n      return this.$el.find(selector);\r\n    },\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // **render** is the core function that your view should override, in order\r\n    // to populate its element (`this.el`), with the appropriate HTML. The\r\n    // convention is for **render** to always return `this`.\r\n    render: function() {\r\n      return this;\r\n    },\r\n\r\n    // Remove this view by taking the element out of the DOM, and removing any\r\n    // applicable Backbone.Events listeners.\r\n    remove: function() {\r\n      this.$el.remove();\r\n      this.stopListening();\r\n      return this;\r\n    },\r\n\r\n    // Change the view's element (`this.el` property), including event\r\n    // re-delegation.\r\n    setElement: function(element, delegate) {\r\n      if (this.$el) this.undelegateEvents();\r\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\r\n      this.el = this.$el[0];\r\n      if (delegate !== false) this.delegateEvents();\r\n      return this;\r\n    },\r\n\r\n    // Set callbacks, where `this.events` is a hash of\r\n    //\r\n    // *{\"event selector\": \"callback\"}*\r\n    //\r\n    //     {\r\n    //       'mousedown .title':  'edit',\r\n    //       'click .button':     'save',\r\n    //       'click .open':       function(e) { ... }\r\n    //     }\r\n    //\r\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\r\n    // Uses event delegation for efficiency.\r\n    // Omitting the selector binds the event to `this.el`.\r\n    // This only works for delegate-able events: not `focus`, `blur`, and\r\n    // not `change`, `submit`, and `reset` in Internet Explorer.\r\n    delegateEvents: function(events) {\r\n      if (!(events || (events = _.result(this, 'events')))) return this;\r\n      this.undelegateEvents();\r\n      for (var key in events) {\r\n        var method = events[key];\r\n        if (!_.isFunction(method)) method = this[events[key]];\r\n        if (!method) continue;\r\n\r\n        var match = key.match(delegateEventSplitter);\r\n        var eventName = match[1], selector = match[2];\r\n        method = _.bind(method, this);\r\n        eventName += '.delegateEvents' + this.cid;\r\n        if (selector === '') {\r\n          this.$el.on(eventName, method);\r\n        } else {\r\n          this.$el.on(eventName, selector, method);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\r\n    // You usually don't need to use this, but may wish to if you have multiple\r\n    // Backbone views attached to the same DOM element.\r\n    undelegateEvents: function() {\r\n      this.$el.off('.delegateEvents' + this.cid);\r\n      return this;\r\n    },\r\n\r\n    // Ensure that the View has a DOM element to render into.\r\n    // If `this.el` is a string, pass it through `$()`, take the first\r\n    // matching element, and re-assign it to `el`. Otherwise, create\r\n    // an element from the `id`, `className` and `tagName` properties.\r\n    _ensureElement: function() {\r\n      if (!this.el) {\r\n        var attrs = _.extend({}, _.result(this, 'attributes'));\r\n        if (this.id) attrs.id = _.result(this, 'id');\r\n        if (this.className) attrs['class'] = _.result(this, 'className');\r\n        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\r\n        this.setElement($el, false);\r\n      } else {\r\n        this.setElement(_.result(this, 'el'), false);\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.Router\r\n  // ---------------\r\n\r\n  // Routers map faux-URLs to actions, and fire events when routes are\r\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\r\n  var Router = Backbone.Router = function(options) {\r\n    options || (options = {});\r\n    if (options.routes) this.routes = options.routes;\r\n    this._bindRoutes();\r\n    this.initialize.apply(this, arguments);\r\n  };\r\n\r\n  // Cached regular expressions for matching named param parts and splatted\r\n  // parts of route strings.\r\n  var optionalParam = /\\((.*?)\\)/g;\r\n  var namedParam    = /(\\(\\?)?:\\w+/g;\r\n  var splatParam    = /\\*\\w+/g;\r\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\r\n\r\n  // Set up all inheritable **Backbone.Router** properties and methods.\r\n  _.extend(Router.prototype, {\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // Manually bind a single named route to a callback. For example:\r\n    //\r\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\r\n    //       ...\r\n    //     });\r\n    //\r\n    route: function(route, name, callback) {\r\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\r\n      if (_.isFunction(name)) {\r\n        callback = name;\r\n        name = '';\r\n      }\r\n      if (!callback) callback = this[name];\r\n      var router = this;\r\n      Backbone.history.route(route, function(fragment) {\r\n        var args = router._extractParameters(route, fragment);\r\n        if (router.execute(callback, args, name) !== false) {\r\n        router.trigger.apply(router, ['route:' + name].concat(args));\r\n        router.trigger('route', name, args);\r\n        Backbone.history.trigger('route', router, name, args);\r\n        }\r\n      });\r\n      return this;\r\n    },\r\n\r\n    // Execute a route handler with the provided parameters.  This is an\r\n    // excellent place to do pre-route setup or post-route cleanup.\r\n    execute: function(callback, args, name) {\r\n      if (callback) callback.apply(this, args);\r\n    },\r\n\r\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\r\n    navigate: function(fragment, options) {\r\n      Backbone.history.navigate(fragment, options);\r\n      return this;\r\n    },\r\n\r\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\r\n    // order of the routes here to support behavior where the most general\r\n    // routes can be defined at the bottom of the route map.\r\n    _bindRoutes: function() {\r\n      if (!this.routes) return;\r\n      this.routes = _.result(this, 'routes');\r\n      var route, routes = _.keys(this.routes);\r\n      while ((route = routes.pop()) != null) {\r\n        this.route(route, this.routes[route]);\r\n      }\r\n    },\r\n\r\n    // Convert a route string into a regular expression, suitable for matching\r\n    // against the current location hash.\r\n    _routeToRegExp: function(route) {\r\n      route = route.replace(escapeRegExp, '\\\\$&')\r\n                   .replace(optionalParam, '(?:$1)?')\r\n                   .replace(namedParam, function(match, optional) {\r\n                     return optional ? match : '([^/?]+)';\r\n                   })\r\n                   .replace(splatParam, '([^?]*?)');\r\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\r\n    },\r\n\r\n    // Given a route, and a URL fragment that it matches, return the array of\r\n    // extracted decoded parameters. Empty or unmatched parameters will be\r\n    // treated as `null` to normalize cross-browser behavior.\r\n    _extractParameters: function(route, fragment) {\r\n      var params = route.exec(fragment).slice(1);\r\n      return _.map(params, function(param, i) {\r\n        // Don't decode the search params.\r\n        if (i === params.length - 1) return param || null;\r\n        return param ? decodeURIComponent(param) : null;\r\n      });\r\n    }\r\n\r\n  });\r\n\r\n  // Backbone.History\r\n  // ----------------\r\n\r\n  // Handles cross-browser history management, based on either\r\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\r\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\r\n  // and URL fragments. If the browser supports neither (old IE, natch),\r\n  // falls back to polling.\r\n  var History = Backbone.History = function() {\r\n    this.handlers = [];\r\n    this.checkUrl = _.bind(this.checkUrl, this);\r\n\r\n    // Ensure that `History` can be used outside of the browser.\r\n    if (typeof window !== 'undefined') {\r\n      this.location = window.location;\r\n      this.history = window.history;\r\n    }\r\n  };\r\n\r\n  // Cached regex for stripping a leading hash/slash and trailing space.\r\n  var routeStripper = /^[#\\/]|\\s+$/g;\r\n\r\n  // Cached regex for stripping leading and trailing slashes.\r\n  var rootStripper = /^\\/+|\\/+$/g;\r\n\r\n\r\n\r\n  // Cached regex for stripping urls of hash.\r\n  var pathStripper = /#.*$/;\r\n\r\n  // Has the history handling already been started?\r\n  History.started = false;\r\n\r\n  // Set up all inheritable **Backbone.History** properties and methods.\r\n  _.extend(History.prototype, {\r\n\r\n    // The default interval to poll for hash changes, if necessary, is\r\n    // twenty times a second.\r\n    interval: 50,\r\n\r\n    // Are we at the app root?\r\n    atRoot: function() {\r\n      var path = this.location.pathname.replace(/[^\\/]$/, '$&/');\r\n      return path === this.root && !this.getSearch();\r\n    },\r\n\r\n    // Does the pathname match the root?\r\n    matchRoot: function() {\r\n      var path = this.decodeFragment(this.location.pathname);\r\n      var root = path.slice(0, this.root.length - 1) + '/';\r\n      return root === this.root;\r\n    },\r\n    // Unicode characters in `location.pathname` are percent encoded so they're\r\n    // decoded for comparison. `%25` should not be decoded since it may be part\r\n    // of an encoded parameter.\r\n    decodeFragment: function(fragment) {\r\n      return decodeURI(fragment.replace(/%25/g, '%2525'));\r\n    },\r\n    // In IE6, the hash fragment and search params are incorrect if the\r\n    // fragment contains `?`.\r\n    getSearch: function() {\r\n      var match = this.location.href.replace(/#.*/, '').match(/\\?.+/);\r\n      return match ? match[0] : '';\r\n    },\r\n    // Gets the true hash value. Cannot use location.hash directly due to bug\r\n    // in Firefox where location.hash will always be decoded.\r\n    getHash: function(window) {\r\n      var match = (window || this).location.href.match(/#(.*)$/);\r\n      return match ? match[1] : '';\r\n    },\r\n\r\n    // Get the pathname and search params, without the root.\r\n    getPath: function() {\r\n      var path = this.decodeFragment(\r\n        this.location.pathname + this.getSearch()\r\n      ).slice(this.root.length - 1);\r\n      return path.charAt(0) === '/' ? path.slice(1) : path;\r\n    },\r\n\r\n    // Get the cross-browser normalized URL fragment from the path or hash.\r\n    getFragment: function(fragment) {\r\n      if (fragment == null) {\r\n        if (this._usePushState || !this._wantsHashChange) {\r\n          fragment = this.getPath();\r\n        } else {\r\n          fragment = this.getHash();\r\n        }\r\n      }\r\n      return fragment.replace(routeStripper, '');\r\n    },\r\n\r\n    // Start the hash change handling, returning `true` if the current URL matches\r\n    // an existing route, and `false` otherwise.\r\n    start: function(options) {\r\n      if (History.started) throw new Error('Backbone.history has already been started');\r\n      History.started = true;\r\n\r\n      // Figure out the initial configuration. Do we need an iframe?\r\n      // Is pushState desired ... is it available?\r\n      this.options          = _.extend({root: '/'}, this.options, options);\r\n      this.root             = this.options.root;\r\n      this._wantsHashChange = this.options.hashChange !== false;\r\n      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);\r\n      this._useHashChange   = this._wantsHashChange && this._hasHashChange;\r\n      this._wantsPushState  = !!this.options.pushState;\r\n      this._hasPushState    = !!(this.history && this.history.pushState);\r\n      this._usePushState    = this._wantsPushState && this._hasPushState;\r\n      this.fragment         = this.getFragment();\r\n\r\n      // Normalize root to always include a leading and trailing slash.\r\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\r\n\r\n\r\n\r\n\r\n      // Transition from hashChange to pushState or vice versa if both are\r\n      // requested.\r\n      if (this._wantsHashChange && this._wantsPushState) {\r\n\r\n        // If we've started off with a route from a `pushState`-enabled\r\n        // browser, but we're currently in a browser that doesn't support it...\r\n        if (!this._hasPushState && !this.atRoot()) {\r\n          var root = this.root.slice(0, -1) || '/';\r\n          this.location.replace(root + '#' + this.getPath());\r\n          // Return immediately as browser will do redirect to new url\r\n          return true;\r\n\r\n        // Or if we've started out with a hash-based route, but we're currently\r\n        // in a browser where it could be `pushState`-based instead...\r\n        } else if (this._hasPushState && this.atRoot()) {\r\n          this.navigate(this.getHash(), {replace: true});\r\n        }\r\n\r\n        }\r\n\r\n      // Proxy an iframe to handle location events if the browser doesn't\r\n      // support the `hashchange` event, HTML5 history, or the user wants\r\n      // `hashChange` but not `pushState`.\r\n      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\r\n        this.iframe = document.createElement('iframe');\r\n        this.iframe.src = 'javascript:0';\r\n        this.iframe.style.display = 'none';\r\n        this.iframe.tabIndex = -1;\r\n        var body = document.body;\r\n        // Using `appendChild` will throw on IE < 9 if the document is not ready.\r\n        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\r\n        iWindow.document.open();\r\n        iWindow.document.close();\r\n        iWindow.location.hash = '#' + this.fragment;\r\n      }\r\n\r\n      // Add a cross-platform `addEventListener` shim for older browsers.\r\n      var addEventListener = window.addEventListener || function (eventName, listener) {\r\n        return attachEvent('on' + eventName, listener);\r\n      };\r\n      // Depending on whether we're using pushState or hashes, and whether\r\n      // 'onhashchange' is supported, determine how we check the URL state.\r\n      if (this._usePushState) {\r\n        addEventListener('popstate', this.checkUrl, false);\r\n      } else if (this._useHashChange && !this.iframe) {\r\n        addEventListener('hashchange', this.checkUrl, false);\r\n      } else if (this._wantsHashChange) {\r\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\r\n      }\r\n      if (!this.options.silent) return this.loadUrl();\r\n    },\r\n\r\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\r\n    // but possibly useful for unit testing Routers.\r\n    stop: function() {\r\n      // Add a cross-platform `removeEventListener` shim for older browsers.\r\n      var removeEventListener = window.removeEventListener || function (eventName, listener) {\r\n        return detachEvent('on' + eventName, listener);\r\n      };\r\n      // Remove window listeners.\r\n      if (this._usePushState) {\r\n        removeEventListener('popstate', this.checkUrl, false);\r\n      } else if (this._useHashChange && !this.iframe) {\r\n        removeEventListener('hashchange', this.checkUrl, false);\r\n      }\r\n      // Clean up the iframe if necessary.\r\n      if (this.iframe) {\r\n        document.body.removeChild(this.iframe);\r\n        this.iframe = null;\r\n      }\r\n      // Some environments will throw when clearing an undefined interval.\r\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\r\n      History.started = false;\r\n    },\r\n\r\n    // Add a route to be tested when the fragment changes. Routes added later\r\n    // may override previous routes.\r\n    route: function(route, callback) {\r\n      this.handlers.unshift({route: route, callback: callback});\r\n    },\r\n\r\n    // Checks the current URL to see if it has changed, and if it has,\r\n    // calls `loadUrl`, normalizing across the hidden iframe.\r\n    checkUrl: function(e) {\r\n      var current = this.getFragment();\r\n      // If the user pressed the back button, the iframe's hash will have\r\n      // changed and we should use that for comparison.\r\n      if (current === this.fragment && this.iframe) {\r\n        current = this.getHash(this.iframe.contentWindow);\r\n      }\r\n      if (current === this.fragment) return false;\r\n      if (this.iframe) this.navigate(current);\r\n      this.loadUrl();\r\n    },\r\n\r\n    // Attempt to load the current URL fragment. If a route succeeds with a\r\n    // match, returns `true`. If no defined routes matches the fragment,\r\n    // returns `false`.\r\n    loadUrl: function(fragment) {\r\n      // If the root doesn't match, no routes can match either.\r\n      if (!this.matchRoot()) return false;\r\n      fragment = this.fragment = this.getFragment(fragment);\r\n      return _.some(this.handlers, function(handler) {\r\n        if (handler.route.test(fragment)) {\r\n          handler.callback(fragment);\r\n          return true;\r\n        }\r\n      });\r\n    },\r\n\r\n    // Save a fragment into the hash history, or replace the URL state if the\r\n    // 'replace' option is passed. You are responsible for properly URL-encoding\r\n    // the fragment in advance.\r\n    //\r\n    // The options object can contain `trigger: true` if you wish to have the\r\n    // route callback be fired (not usually desirable), or `replace: true`, if\r\n    // you wish to modify the current URL without adding an entry to the history.\r\n    navigate: function(fragment, options) {\r\n      if (!History.started) return false;\r\n      if (!options || options === true) options = {trigger: !!options};\r\n\r\n      // Normalize the fragment.\r\n      fragment = this.getFragment(fragment || '');\r\n\r\n      // Don't include a trailing slash on the root.\r\n      var root = this.root;\r\n      if (fragment === '' || fragment.charAt(0) === '?') {\r\n        root = root.slice(0, -1) || '/';\r\n      }\r\n      var url = root + fragment;\r\n      // Strip the hash and decode for matching.\r\n      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));\r\n\r\n      if (this.fragment === fragment) return;\r\n      this.fragment = fragment;\r\n\r\n\r\n      // If pushState is available, we use it to set the fragment as a real URL.\r\n      if (this._usePushState) {\r\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n\r\n      // If hash changes haven't been explicitly disabled, update the hash\r\n      // fragment to store history.\r\n      } else if (this._wantsHashChange) {\r\n        this._updateHash(this.location, fragment, options.replace);\r\n        if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {\r\n          var iWindow = this.iframe.contentWindow;\r\n          // Opening and closing the iframe tricks IE7 and earlier to push a\r\n          // history entry on hash-tag change.  When replace is true, we don't\r\n          // want this.\r\n          if (!options.replace) {\r\n            iWindow.document.open();\r\n            iWindow.document.close();\r\n          }\r\n\r\n          this._updateHash(iWindow.location, fragment, options.replace);\r\n        }\r\n\r\n      // If you've told us that you explicitly don't want fallback hashchange-\r\n      // based history, then `navigate` becomes a page refresh.\r\n      } else {\r\n        return this.location.assign(url);\r\n      }\r\n      if (options.trigger) return this.loadUrl(fragment);\r\n    },\r\n\r\n    // Update the hash location, either replacing the current entry, or adding\r\n    // a new one to the browser history.\r\n    _updateHash: function(location, fragment, replace) {\r\n      if (replace) {\r\n        var href = location.href.replace(/(javascript:|#).*$/, '');\r\n        location.replace(href + '#' + fragment);\r\n      } else {\r\n        // Some browsers require that `hash` contains a leading #.\r\n        location.hash = '#' + fragment;\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  // Create the default Backbone.history.\r\n  Backbone.history = new History;\r\n\r\n  return Backbone;\r\n\r\n}));\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/backbone.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"commonjs\":\"underscore\",\"commonjs2\":\"underscore\",\"amd\":\"underscore\",\"root\":\"_\"}\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\",\"root\":\"$\"}\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\r\n\r\nvar _ = require( 'underscore' );\r\n\r\nvar Events = {};\r\n\r\n// So hard to believe :) You won't. Optimized JIT-friendly event trigger functions to be used from model.set\r\n// Two specialized functions for event triggering...\r\nEvents.trigger1 = function( self, name, a ){\r\n    var _events = self._events;\r\n    if( _events ){\r\n        _fireEvent1( _events[ name ], a );\r\n        _fireEvent2( _events.all, name, a );\r\n    }\r\n};\r\n\r\nEvents.trigger2 = function( self, name, a, b ){\r\n    var _events = self._events;\r\n    if( _events ){\r\n        _fireEvent2( _events[ name ], a, b );\r\n        _fireEvent3( _events.all, name, a, b );\r\n    }\r\n};\r\n\r\nEvents.trigger3 = function( self, name, a, b, c ){\r\n    var _events = self._events;\r\n    if( _events ){\r\n        _fireEvent3( _events[ name ], a, b, c );\r\n        _fireEvent4( _events.all, name, a, b, c );\r\n    }\r\n};\r\n\r\nEvents.onAll = function( self, callback, context ){\r\n    var record = {callback: callback, context: context, ctx: context || self},\r\n        _events = self._events || ( self._events = {} ),\r\n        events = _events.all;\r\n\r\n    if( events ){\r\n        events.push( record );\r\n    }\r\n    else{\r\n        _events.all = [ record ];\r\n    }\r\n\r\n    return self;\r\n};\r\n\r\nEvents.offAll = function( self, callback, context) {\r\n    var retain, ev, events, j, k;\r\n    if( !self._events ) return self;\r\n\r\n    if (events = self._events.all ) {\r\n        self._events.all = retain = [];\r\n\r\n        if( callback || context ) {\r\n            for (j = 0, k = events.length; j < k; j++) {\r\n                ev = events[j];\r\n                if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\r\n                    (context && context !== ev.context)) {\r\n                    retain.push(ev);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!retain.length) delete self._events.all;\r\n    }\r\n\r\n    return self;\r\n};\r\n\r\n// ...and specialized functions with triggering loops. Crappy JS JIT loves these small functions and code duplication.\r\nfunction _fireEvent1( events, a ){\r\n    if( events )\r\n        for( var i = 0, l = events.length, ev; i < l; i ++ )\r\n            (ev = events[i]).callback.call(ev.ctx, a );\r\n}\r\n\r\nfunction _fireEvent2( events, a, b ){\r\n    if( events )\r\n        for( var i = 0, l = events.length, ev; i < l; i ++ )\r\n            (ev = events[i]).callback.call(ev.ctx, a, b);\r\n}\r\n\r\nfunction _fireEvent3( events, a, b, c ){\r\n    if( events )\r\n        for( var i = 0, l = events.length, ev; i < l; i ++ )\r\n            (ev = events[i]).callback.call(ev.ctx, a, b, c);\r\n}\r\n\r\nfunction _fireEvent4( events, a, b, c, d ){\r\n    if( events )\r\n        for( var i = 0, l = events.length, ev; i < l; i ++ )\r\n            (ev = events[i]).callback.call(ev.ctx, a, b, c, d);\r\n}\r\n\r\n// Backbone.Events\r\n// ---------------\r\n\r\n// A module that can be mixed in to *any object* in order to provide it with\r\n// a custom event channel. You may bind a callback to an event with `on` or\r\n// remove with `off`; `trigger`-ing an event fires all callbacks in\r\n// succession.\r\n//\r\n//     var object = {};\r\n//     _.extend(object, Backbone.Events);\r\n//     object.on('expand', function(){ alert('expanded'); });\r\n//     object.trigger('expand');\r\n//\r\n\r\n// Regular expression used to split event strings.\r\nvar eventSplitter = /\\s+/;\r\n\r\n// Iterates over the standard `event, callback` (as well as the fancy multiple\r\n// space-separated events `\"change blur\", callback` and jQuery-style event\r\n// maps `{event: callback}`).\r\nvar eventsApi = function(iteratee, events, name, callback, opts) {\r\n    var i = 0, names;\r\n    if (name && typeof name === 'object') {\r\n        // Handle event maps.\r\n        if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\r\n        for (names = _.keys(name); i < names.length ; i++) {\r\n            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\r\n        }\r\n    } else if (name && eventSplitter.test(name)) {\r\n        // Handle space separated event names by delegating them individually.\r\n        for (names = name.split(eventSplitter); i < names.length; i++) {\r\n            events = iteratee(events, names[i], callback, opts);\r\n        }\r\n    } else {\r\n        // Finally, standard events.\r\n        events = iteratee(events, name, callback, opts);\r\n    }\r\n    return events;\r\n};\r\n\r\n// Bind an event to a `callback` function. Passing `\"all\"` will bind\r\n// the callback to all events fired.\r\nEvents.on = function(name, callback, context) {\r\n    return internalOn(this, name, callback, context);\r\n};\r\n\r\n// Guard the `listening` argument from the public API.\r\nvar internalOn = function(obj, name, callback, context, listening) {\r\n    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {\r\n        context: context,\r\n        ctx: obj,\r\n        listening: listening\r\n    });\r\n\r\n    if (listening) {\r\n        var listeners = obj._listeners || (obj._listeners = {});\r\n        listeners[listening.id] = listening;\r\n    }\r\n\r\n    return obj;\r\n};\r\n\r\n// Inversion-of-control versions of `on`. Tell *this* object to listen to\r\n// an event in another object... keeping track of what it's listening to\r\n// for easier unbinding later.\r\nEvents.listenTo =  function(obj, name, callback) {\r\n    if (!obj) return this;\r\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\r\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\r\n    var listening = listeningTo[id];\r\n\r\n    // This object is not listening to any other events on `obj` yet.\r\n    // Setup the necessary references to track the listening callbacks.\r\n    if (!listening) {\r\n        var thisId = this._listenId || (this._listenId = _.uniqueId('l'));\r\n        listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};\r\n    }\r\n\r\n    // Bind callbacks on obj, and keep track of them on listening.\r\n    internalOn(obj, name, callback, this, listening);\r\n    return this;\r\n};\r\n\r\n// The reducing API that adds a callback to the `events` object.\r\nvar onApi = function(events, name, callback, options) {\r\n    if (callback) {\r\n        var handlers = events[name] || (events[name] = []);\r\n        var context = options.context, ctx = options.ctx, listening = options.listening;\r\n        if (listening) listening.count++;\r\n\r\n        handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\r\n    }\r\n    return events;\r\n};\r\n\r\n// Remove one or many callbacks. If `context` is null, removes all\r\n// callbacks with that function. If `callback` is null, removes all\r\n// callbacks for the event. If `name` is null, removes all bound\r\n// callbacks for all events.\r\nEvents.off =  function(name, callback, context) {\r\n    if (!this._events) return this;\r\n    this._events = eventsApi(offApi, this._events, name, callback, {\r\n        context: context,\r\n        listeners: this._listeners\r\n    });\r\n    return this;\r\n};\r\n\r\n// Tell this object to stop listening to either specific events ... or\r\n// to every object it's currently listening to.\r\nEvents.stopListening =  function(obj, name, callback) {\r\n    var listeningTo = this._listeningTo;\r\n    if (!listeningTo) return this;\r\n\r\n    var ids = obj ? [obj._listenId] : _.keys(listeningTo);\r\n\r\n    for (var i = 0; i < ids.length; i++) {\r\n        var listening = listeningTo[ids[i]];\r\n\r\n        // If listening doesn't exist, this object is not currently\r\n        // listening to obj. Break out early.\r\n        if (!listening) break;\r\n\r\n        listening.obj.off(name, callback, this);\r\n    }\r\n    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;\r\n\r\n    return this;\r\n};\r\n\r\n// The reducing API that removes a callback from the `events` object.\r\nvar offApi = function(events, name, callback, options) {\r\n    if (!events) return;\r\n\r\n    var i = 0, listening;\r\n    var context = options.context, listeners = options.listeners;\r\n\r\n    // Delete all events listeners and \"drop\" events.\r\n    if (!name && !callback && !context) {\r\n        var ids = _.keys(listeners);\r\n        for (; i < ids.length; i++) {\r\n            listening = listeners[ids[i]];\r\n            delete listeners[listening.id];\r\n            delete listening.listeningTo[listening.objId];\r\n        }\r\n        return;\r\n    }\r\n\r\n    var names = name ? [name] : _.keys(events);\r\n    for (; i < names.length; i++) {\r\n        name = names[i];\r\n        var handlers = events[name];\r\n\r\n        // Bail out if there are no events stored.\r\n        if (!handlers) break;\r\n\r\n        // Replace events if there are any remaining.  Otherwise, clean up.\r\n        var remaining = [];\r\n        for (var j = 0; j < handlers.length; j++) {\r\n            var handler = handlers[j];\r\n            if (\r\n                callback && callback !== handler.callback &&\r\n                callback !== handler.callback._callback ||\r\n                context && context !== handler.context\r\n            ) {\r\n                remaining.push(handler);\r\n            } else {\r\n                listening = handler.listening;\r\n                if (listening && --listening.count === 0) {\r\n                    delete listeners[listening.id];\r\n                    delete listening.listeningTo[listening.objId];\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update tail event if the list has any events.  Otherwise, clean up.\r\n        if (remaining.length) {\r\n            events[name] = remaining;\r\n        } else {\r\n            delete events[name];\r\n        }\r\n    }\r\n    if (_.size(events)) return events;\r\n};\r\n\r\n// Bind an event to only be triggered a single time. After the first time\r\n// the callback is invoked, its listener will be removed. If multiple events\r\n// are passed in using the space-separated syntax, the handler will fire\r\n// once for each event, not once for a combination of all events.\r\nEvents.once =  function(name, callback, context) {\r\n    // Map the event into a `{event: once}` object.\r\n    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));\r\n    return this.on(events, void 0, context);\r\n};\r\n\r\n// Inversion-of-control versions of `once`.\r\nEvents.listenToOnce =  function(obj, name, callback) {\r\n    // Map the event into a `{event: once}` object.\r\n    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));\r\n    return this.listenTo(obj, events);\r\n};\r\n\r\n// Reduces the event callbacks into a map of `{event: onceWrapper}`.\r\n// `offer` unbinds the `onceWrapper` after it has been called.\r\nvar onceMap = function(map, name, callback, offer) {\r\n    if (callback) {\r\n        var once = map[name] = _.once(function() {\r\n            offer(name, once);\r\n            callback.apply(this, arguments);\r\n        });\r\n        once._callback = callback;\r\n    }\r\n    return map;\r\n};\r\n\r\n// Trigger one or many events, firing all bound callbacks. Callbacks are\r\n// passed the same arguments as `trigger` is, apart from the event name\r\n// (unless you're listening on `\"all\"`, which will cause your callback to\r\n// receive the true name of the event as the first argument).\r\nEvents.trigger =  function(name) {\r\n    if (!this._events) return this;\r\n\r\n    var length = Math.max(0, arguments.length - 1);\r\n    var args = Array(length);\r\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\r\n\r\n    eventsApi(triggerApi, this._events, name, void 0, args);\r\n    return this;\r\n};\r\n\r\n// Handles triggering the appropriate event callbacks.\r\nvar triggerApi = function(objEvents, name, cb, args) {\r\n    if (objEvents) {\r\n        var events = objEvents[name];\r\n        var allEvents = objEvents.all;\r\n        if (events && allEvents) allEvents = allEvents.slice();\r\n        if (events) triggerEvents(events, args);\r\n        if (allEvents) triggerEvents(allEvents, [name].concat(args));\r\n    }\r\n    return objEvents;\r\n};\r\n\r\n// A difficult-to-believe, but optimized internal dispatch function for\r\n// triggering events. Tries to keep the usual cases speedy (most internal\r\n// Backbone events have 3 arguments).\r\nvar triggerEvents = function(events, args) {\r\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\r\n    switch (args.length) {\r\n        case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\r\n        case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\r\n        case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\r\n        case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\r\n        default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\r\n    }\r\n};\r\n\r\n// Aliases for backwards compatibility.\r\nEvents.bind   = Events.on;\r\nEvents.unbind = Events.off;\r\n\r\n// Allow the `Backbone` object to serve as a global event bus, for folks who\r\n// want global \"pubsub\" in a convenient place.\r\nmodule.exports = Events;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/events-mixin.js\n ** module id = 7\n ** module chunks = 0\n **/","// Optimized Model.set functions\r\n//---------------------------------\r\n/*\r\n Does two main things:\r\n 1) Invoke model-specific constructor for attributes cloning. It improves performance on large model updates.\r\n 2) Invoke attribute-specific comparison function. Improves performance for everything, especially nested stuff.\r\n\r\n attrSpec is required to provide two methods:\r\n transform( value, options, model, name ) -> value\r\n to transform value before assignment\r\n\r\n isChanged( value1, value2 ) -> bool\r\n to detect whenever attribute must be assigned and counted as changed\r\n\r\n Model is required to implement Attributes constructor for attributes cloning.\r\n */\r\n\r\n// Special case set: used from model's native properties.\r\n// Single attribute change, no options, _no_ _nested_ _changes_ detection on deep update.\r\n// 1) Code is stripped for this special case\r\n// 2) attribute-specific transform function invoked internally\r\n\r\nvar _        = require( 'underscore' ),\r\n    Events   = require( './backbone+' ).Events,\r\n    error    = require( './errors' ),\r\n    trigger2 = Events.trigger2,\r\n    trigger3 = Events.trigger3;\r\n\r\nmodule.exports = {\r\n    isChanged     : genericIsChanged,\r\n    setSingleAttr : setSingleAttr,\r\n    setAttrs      : setAttrs,\r\n    transaction   : transaction,\r\n    transform     : applyTransform,\r\n    __begin       : __begin,\r\n    __commit      : __commit\r\n};\r\n\r\nfunction genericIsChanged( a, b ){\r\n    return !( a === b || ( a && b && typeof a == 'object' && typeof b == 'object' && _.isEqual( a, b ) ) );\r\n}\r\n\r\nfunction setSingleAttr( model, key, value, attrSpec ){\r\n    'use strict';\r\n    var changing = model._changing,\r\n        current  = model.attributes;\r\n\r\n    model._changing = true;\r\n\r\n    if( !changing ){\r\n        model._previousAttributes = new model.Attributes( current );\r\n    }\r\n\r\n    if( model._changed ) model._changed = null;\r\n\r\n    var options   = {},\r\n        prevValue = current[ key ],\r\n        val       = attrSpec.transform( value, options, model, key );\r\n\r\n    current[ key ] = val;\r\n\r\n    if( attrSpec.isChanged( prevValue, val ) ){\r\n        model._pending = options;\r\n        trigger3( model, 'change:' + key, model, val, options );\r\n    }\r\n\r\n    if( changing ){\r\n        return model;\r\n    }\r\n\r\n    while( model._pending ){\r\n        options        = model._pending;\r\n        model._pending = false;\r\n        model._changeToken = {};\r\n        trigger2( model, 'change', model, options );\r\n    }\r\n\r\n    model._pending  = false;\r\n    model._changing = false;\r\n    return model;\r\n}\r\n\r\n\r\n// call a_fun with a_args inside of set transaction.\r\n// model.set inside of a_fun will trigger change:attr\r\n// but only single 'change' will be triggered at the end of transaction\r\n// transactions can be nested\r\nfunction transaction( a_fun, context, args ){\r\n    var notChanging = !this._changing,\r\n        options  = {};\r\n\r\n    this._changing = true;\r\n\r\n\r\n    if( notChanging ){\r\n        this._previousAttributes = new this.Attributes( this.attributes );\r\n    }\r\n\r\n    if( this._changed ) this._changed = null;\r\n\r\n    this.__begin();\r\n    var res = a_fun.apply( context || this, args );\r\n    this.__commit();\r\n\r\n    if( notChanging ){\r\n        while( this._pending ){\r\n            options       = this._pending;\r\n            this._pending = false;\r\n            this._changeToken = {};\r\n            trigger2( this, 'change', this, options );\r\n        }\r\n\r\n        this._pending  = false;\r\n        this._changing = false;\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\n// General case set: used for multiple and nested model/collection attributes.\r\n// Does _not_ invoke attribute transform! It must be done at the the top level,\r\n// due to the problems with current nested changes detection algorithm. See 'setAttrs' function below.\r\nfunction bbSetAttrs( model, attrs, opts ){\r\n    'use strict';\r\n    var options = opts || {};\r\n\r\n    // Extract attributes and options.\r\n    var unset     = options.unset,\r\n        silent    = options.silent,\r\n        changes   = [],\r\n        changing  = model._changing,\r\n        current   = model.attributes,\r\n        attrSpecs = model.__attributes;\r\n\r\n    model._changing = true;\r\n\r\n    if( !changing ){\r\n        model._previousAttributes = new model.Attributes( current );\r\n    }\r\n\r\n    if( model._changed ) model._changed = null;\r\n\r\n    // For each `set` attribute, update or delete the current value.\r\n    // Todo: optimize for complete attrs set. Iterate through attributes names array,\r\n    // or (may be better) create precompiled loop unrolled forEach, extracting specs\r\n    // and values.\r\n    // Beware of single attr update with options. Need deep refactoring to remove penalty.\r\n    for( var attr in attrs ){\r\n        var attrSpec  = attrSpecs[ attr ],\r\n            isChanged = attrSpec ? attrSpec.isChanged : genericIsChanged,\r\n            val       = unset ? undefined : attrs[ attr ];\r\n\r\n        if( isChanged( current[ attr ], val ) ){\r\n            changes.push( attr );\r\n        }\r\n\r\n        current[ attr ] = val;\r\n    }\r\n\r\n    // Trigger all relevant attribute changes.\r\n    if( !silent ){\r\n        if( changes.length ){\r\n            model._pending = options;\r\n        }\r\n        for( var i = 0, l = changes.length; i < l; i++ ){\r\n            attr = changes[ i ];\r\n            trigger3( model, 'change:' + attr, model, current[ attr ], options );\r\n        }\r\n    }\r\n\r\n    // You might be wondering why there's a `while` loop here. Changes can\r\n    // be recursively nested within `\"change\"` events.\r\n    if( changing ){\r\n        return model;\r\n    }\r\n    if( !silent ){\r\n        while( model._pending ){\r\n            options        = model._pending;\r\n            model._pending = false;\r\n            model._changeToken = {};\r\n            trigger2( model, 'change', model, options );\r\n        }\r\n    }\r\n\r\n    model._pending  = false;\r\n    model._changing = false;\r\n\r\n    return model;\r\n}\r\n\r\n// Optimized Backbone Core functions\r\n// =================================\r\n// Deep set model attributes, catching nested attributes changes\r\nfunction setAttrs( model, attrs, options ){\r\n    model.__begin();\r\n\r\n    applyTransform( model, attrs, model.__attributes, options );\r\n\r\n    model.__commit( attrs, options );\r\n\r\n    return model;\r\n}\r\n\r\n// transform attributes hash\r\nfunction applyTransform( model, attrs, attrSpecs, options ){\r\n    for( var name in attrs ){\r\n        var attrSpec = attrSpecs[ name ], value = attrs[ name ];\r\n        if( attrSpec ){\r\n            attrs[ name ] = attrSpec.transform( value, options, model, name );\r\n        }\r\n        else{\r\n            error.unknownAttribute( model, name, value );\r\n        }\r\n    }\r\n}\r\n\r\nfunction __begin(){\r\n    this.__duringSet++ || ( this.__nestedChanges = {} );\r\n}\r\n\r\nfunction __commit( a_attrs, options ){\r\n    var attrs = a_attrs;\r\n\r\n    if( !--this.__duringSet ){\r\n        var nestedChanges = this.__nestedChanges,\r\n            attributes    = this.attributes;\r\n\r\n        attrs || ( attrs = {} );\r\n\r\n        // Catch nested changes.\r\n        for( var name in nestedChanges ){\r\n            var value = name in attrs ? attrs[ name ] : attrs[ name ] = nestedChanges[ name ];\r\n\r\n            if( value === attributes[ name ] ){\r\n                // patch attributes to force change:name event\r\n                attributes[ name ] = null;\r\n            }\r\n        }\r\n\r\n        this.__nestedChanges = {};\r\n    }\r\n\r\n    if( attrs ){\r\n        bbSetAttrs( this, attrs, options );\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modelset.js\n ** module id = 8\n ** module chunks = 0\n **/","require( './object+' );\r\n\r\nfunction format( value ){\r\n    return typeof value === 'string' ? '\"' + value + '\"' : value;\r\n}\r\n\r\nObject.assign( Object.extend.error, {\r\n    argumentIsNotAnObject : function( context, value ){\r\n        //throw new TypeError( 'Attribute hash is not an object in ' + context.__class + '.set(', value, ')' );\r\n        console.error( '[Type Error] Attribute hash is not an object in ' +\r\n                       context.__class + '.set(', format( value ), '); this =', context );\r\n    },\r\n\r\n    wrongWatcher : function( context, ref ){\r\n        console.warn( \"[Reference Error] Attribute's .has.watcher(\", ref, \") must be string reference or function; attr=\", context );\r\n    },\r\n\r\n    unknownAttribute : function( context, name, value ){\r\n        if( context.suppressTypeErrors ) return;\r\n\r\n        console.warn( '[Type Error] Attribute has no default value in ' +\r\n                        context.__class + '.set( \"' + name + '\",', format( value ), '); this =', context );\r\n    },\r\n\r\n    hardRefNotAssignable : function( context, name, value ){\r\n        if( context.suppressTypeErrors ) return;\r\n\r\n        console.warn( '[Type Error] Hard reference cannot be assigned in ' +\r\n                        context.__class + '.set( \"' + name + '\",', format( value ), '); this =', context );\r\n    },\r\n\r\n    wrongCollectionSetArg : function( context, value ){\r\n        //throw new TypeError( 'Wrong argument type in ' + context.__class + '.set(' + value + ')' );\r\n        console.error( '[Type Error] Wrong argument type in ' +\r\n                       context.__class + '.set(', format( value ), '); this =', context );\r\n    },\r\n\r\n    serializeSharedObject : function( context, name, value ){\r\n      console.warn( '[Ownership Error] Shared model/collection is being serialized to JSON, in ' +\r\n                     context.__class + '.' + name + '==', value, '; this =', context );\r\n    }\r\n});\r\n\r\nmodule.exports = Object.extend.error;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/errors.js\n ** module id = 9\n ** module chunks = 0\n **/","// Options wrapper for chained and safe type specs...\r\n// --------------------------------------------------\r\nrequire( './object+' );\r\n\r\nvar trigger3         = require( './backbone+' ).Events.trigger3,\r\n    modelSet         = require( './modelset' ),\r\n    error            = require( './errors' ),\r\n    genericIsChanged = modelSet.isChanged,\r\n    setSingleAttr    = modelSet.setSingleAttr;\r\n\r\nvar primitiveTypes = {\r\n    string  : String,\r\n    number  : Number,\r\n    boolean : Boolean\r\n};\r\n\r\n// list of simple accessor methods available in options\r\nvar availableOptions = [ 'triggerWhenChanged', 'changeEvents', 'parse', 'clone', 'toJSON', 'value', 'cast', 'create', 'name', 'value',\r\n                         'type', 'validate' ];\r\n\r\nfunction parseReference( ref ){\r\n    switch( typeof ref ){\r\n        case 'string' :\r\n            var path     = ( 'self.' + ref.replace( /\\^/g, 'getOwner().' ) ).split( '.' ),\r\n                callback = path.pop(),\r\n                context  = new Function( 'self', 'return ' + path.join( '.' ) );\r\n\r\n            return function( value ){\r\n                var self = context( this );\r\n\r\n                if( self && self[ callback ] ){\r\n                    self[ callback ]( value, this );\r\n                }\r\n\r\n                return value;\r\n            };\r\n        case 'function' :\r\n            return function( value ){\r\n                ref.call( this, value, this );\r\n                return value;\r\n            };\r\n    }\r\n}\r\n\r\nvar Options = Object.extend( {\r\n    _options : {}, // attribute options\r\n\r\n    Attribute : null, // default attribute spec when no type is given, is set to Attribute below\r\n\r\n    properties : {\r\n        has : function(){ return this; }\r\n    },\r\n\r\n    constructor : function( spec ){\r\n        // special option used to guess types of primitive values and to distinguish value from type\r\n        if( 'typeOrValue' in spec ){\r\n            var typeOrValue   = spec.typeOrValue,\r\n                primitiveType = primitiveTypes[ typeof typeOrValue ];\r\n\r\n            if( primitiveType ){\r\n                spec = { type : primitiveType, value : typeOrValue };\r\n            }\r\n            else{\r\n                spec = typeof typeOrValue == 'function' ? { type : typeOrValue } : { value : typeOrValue };\r\n            }\r\n        }\r\n\r\n        this._options = {};\r\n        this.options( spec );\r\n    },\r\n\r\n    watcher : function( ref ){\r\n        var callback = parseReference( ref );\r\n        if( callback ){\r\n            this.set( callback );\r\n        }\r\n        else{\r\n            error.wrongWatcher( this, ref );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    check : function( check, error ){\r\n        var prevValidate = this._options.validate;\r\n\r\n        var validate = prevValidate ? function( model, value, name ){\r\n            var prevError = prevValidate( model, value, name );\r\n            if( prevError ) return prevError;\r\n\r\n            if( !check.call( model, value, name ) ){\r\n                return error || name + ' is not valid';\r\n            }\r\n        } : function( model, value, name ){\r\n            if( !check.call( model, value, name ) ){\r\n                return error || name + ' is not valid';\r\n            }\r\n        };\r\n\r\n        this._options.validate = validate;\r\n\r\n        return this;\r\n    },\r\n\r\n    proxy : function( attrs ){\r\n        this._options.proxy = attrs || true;\r\n        return this;\r\n    },\r\n\r\n    // get hooks stored as an array\r\n    get : function( getter ){\r\n        var options = this._options;\r\n        options.get = options.get ? options.get.unshift( getter ) : [ getter ];\r\n        return this;\r\n    },\r\n\r\n    // set hooks stored as an array\r\n    set : function( setter ){\r\n        var options = this._options;\r\n        options.set = options.set ? options.set.push( setter ) : [ setter ];\r\n        return this;\r\n    },\r\n\r\n    // events must be merged\r\n    events : function( events ){\r\n        this._options.events = Object.assign( this._options.events || {}, events );\r\n        return this;\r\n    },\r\n\r\n    // options must be merged using rules for individual accessors\r\n    options : function( options ){\r\n        for( var i in options ){\r\n            this[ i ]( options[ i ] );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    // construct attribute with a given name and proper type.\r\n    createAttribute : function( name ){\r\n        var options = this._options,\r\n            Type    = options.type ? options.type.Attribute : this.Attribute;\r\n\r\n        if( options.changeEvents ) options.triggerWhenChanged = options.changeEvents;\r\n\r\n        //TODO: It looks like a bug. Remove.\r\n        if( options.proxy && typeof options.proxy === 'string' && !options.triggerWhenChanged ){\r\n            options.triggerWhenChanged = options.proxy\r\n                                                .split( ' ' )\r\n                                                .map( function( attr ){\r\n                                                    return 'change:' + attr;\r\n                                                } ).join( ' ' );\r\n        }\r\n\r\n        return new Type( name, options );\r\n    }\r\n} );\r\n\r\navailableOptions.forEach( function( name ){\r\n    Options.prototype[ name ] = function( value ){\r\n        this._options[ name ] = value;\r\n        return this;\r\n    };\r\n} );\r\n\r\nfunction chainHooks( array ){\r\n    var l = array.length;\r\n\r\n    return l === 1 ? array[ 0 ] : function( value, name ){\r\n        var res = value;\r\n        for( var i = 0; i < l; i++ ){\r\n            res = array[ i ].call( this, res, name );\r\n        }\r\n        return res;\r\n    };\r\n}\r\n\r\nvar transform = {\r\n    hookAndCast : function( val, options, model, name ){\r\n        var value = this.cast( val, options, model, name ),\r\n            prev  = model.attributes[ name ];\r\n\r\n        if( this.isChanged( value, prev ) ){\r\n            value = this.set.call( model, value, name );\r\n            return value === undefined ? prev : this.cast( value, options, model );\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    hook : function( value, options, model, name ){\r\n        var prev = model.attributes[ name ];\r\n\r\n        if( this.isChanged( value, prev ) ){\r\n            var changed = this.set.call( model, value, name );\r\n            return changed === undefined ? prev : changed;\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    delegateAndMore : function( val, options, model, attr ){\r\n        return this.delegateEvents( this._transform( val, options, model, attr ), options, model, attr );\r\n    }\r\n};\r\n\r\n// Base class for Attribute metatype\r\n// ---------------------------------\r\nfunction proxyProperty( first, second ){\r\n    return {\r\n        get : function(){\r\n            return this[ first ][ second ];\r\n        },\r\n\r\n        set : function( value ){\r\n            this[ first ][ second ] = value;\r\n        }\r\n    }\r\n}\r\n\r\nfunction proxyFunction( first, second ){\r\n    return function(){\r\n        var self = this[ first ];\r\n        return self[ second ].apply( self, arguments );\r\n    }\r\n}\r\n\r\nvar Attribute = Object.extend( {\r\n    name  : null,\r\n    type  : null,\r\n    value : undefined,\r\n\r\n    // cast function\r\n    // may be overriden in subclass\r\n    cast : null, // function( value, options, model ),\r\n\r\n    // get and set hooks...\r\n    get : null,\r\n    set : null,\r\n\r\n    // user events\r\n    events : null, // { event : handler, ... }\r\n\r\n    // system events\r\n    __events : null, // { event : handler, ... }\r\n\r\n    // create empty object passing backbone options to constructor...\r\n    // must be overriden for backbone types only\r\n    create : function( options ){ return new this.type(); },\r\n\r\n    // optimized general purpose isEqual function for typeless attributes\r\n    // must be overriden in subclass\r\n    isChanged : genericIsChanged,\r\n\r\n    // generic clone function for typeless attributes\r\n    // Must be overriden in sublass\r\n    clone : function( value, options ){\r\n        if( value && typeof value === 'object' ){\r\n            var proto = Object.getPrototypeOf( value );\r\n\r\n            if( proto.clone ){\r\n                // delegate to object's clone if it exist\r\n                return value.clone( options );\r\n            }\r\n\r\n            if( options && options.deep && proto === Object.prototype || proto === Array.prototype ){\r\n                // attempt to deep copy raw objects, assuming they are JSON\r\n                return JSON.parse( JSON.stringify( value ) );\r\n            }\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    validate : function( model, value, name ){},\r\n\r\n    toJSON : function( value, key ){\r\n        return value && value.toJSON ? value.toJSON() : value;\r\n    },\r\n\r\n    // must be overriden for backbone types...\r\n    createPropertySpec : function(){\r\n        return (function( self, name, get ){\r\n            return {\r\n                // call to optimized set function for single argument. Doesn't work for backbone types.\r\n                set : function( value ){ setSingleAttr( this, name, value, self ); },\r\n\r\n                // attach get hook to the getter function, if present\r\n                get : get ? function(){ return get.call( this, this.attributes[ name ], name ); } :\r\n                      function(){ return this.attributes[ name ]; }\r\n            }\r\n        })( this, this.name, this.get );\r\n    },\r\n\r\n    attachMixins : function( spec ){\r\n        var type  = this.type,\r\n            proto = type && type.prototype;\r\n\r\n        if( type && this.proxy ){\r\n            var keys = typeof this.proxy === 'string' ? this.proxy.split( ' ' ) : _.allKeys( proto ).concat(\r\n                _.keys( proto.properties ) );\r\n\r\n            // for each enumerable property...\r\n            for( var i = 0; i < keys.length; i++ ){\r\n                var name = keys[ i ];\r\n\r\n                // ...which is not defined in target class\r\n                if( name in spec ) continue;\r\n\r\n                var prop = Object.getPropertyDescriptor( proto, name );\r\n\r\n                // create proxy function, if it the function...\r\n                if( typeof prop.value === 'function' ){\r\n                    spec[ name ] = proxyFunction( this.name, name );\r\n                }\r\n                // ...or create native property, if it's the property.\r\n                // TODO: Looks like extra check. Need to remove. Everything should be proxied.\r\n                else if( prop.get ){\r\n                    Object.defineProperty( spec, name, proxyProperty( this.name, name ) );\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    // automatically generated optimized transform function\r\n    // do not touch.\r\n    _transform : null,\r\n    transform  : function( value ){ return value; },\r\n\r\n    // delegate user and system events on attribute transform\r\n    delegateEvents : function( value, options, model, name ){\r\n        var prev = model.attributes[ name ];\r\n\r\n        if( this.isChanged( prev, value ) ){ //should be changed only when attr is really replaced.\r\n            prev && prev.trigger && model.stopListening( prev );\r\n\r\n            if( value && value.trigger ){\r\n                if( this.events ){\r\n                    model.listenTo( value, this.events );\r\n                }\r\n                if( this.__events ){\r\n                    model.listenTo( value, this.__events );\r\n                }\r\n            }\r\n\r\n            trigger3( model, 'replace:' + name, model, value, prev );\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    constructor : function( name, spec ){\r\n        this.name = name;\r\n\r\n        Object.transform( this, spec, function( value, name ){\r\n            if( name === 'events' && this.events ){\r\n                return Object.assign( this.events, value );\r\n            }\r\n\r\n            if( name === 'get' ){\r\n                if( this.get ){\r\n                    value.unshift( this.get );\r\n                }\r\n                return chainHooks( value );\r\n            }\r\n\r\n            if( name === 'set' ){\r\n                if( this.set ){\r\n                    value.push( this.set );\r\n                }\r\n                return chainHooks( value );\r\n            }\r\n\r\n            return value;\r\n        }, this );\r\n\r\n        this.initialize( spec );\r\n\r\n        // assemble optimized transform function...\r\n        if( this.cast ){\r\n            this.transform = this._transform = this.cast;\r\n        }\r\n        if( this.set ){\r\n            this.transform = this._transform = this.cast ? transform.hookAndCast : transform.hook;\r\n        }\r\n        if( this.events || this.__events ){\r\n            this.transform =\r\n                this._transform ? transform.delegateAndMore : this.delegateEvents;\r\n        }\r\n    }\r\n}, {\r\n    attach : (function(){\r\n        function options( spec ){\r\n            spec || ( spec = {} );\r\n            spec.type || ( spec.type = this );\r\n            return new Options( spec );\r\n        }\r\n\r\n        function value( value ){\r\n            return new Options( { type : this, value : value } );\r\n        }\r\n\r\n        return function(){\r\n            for( var i = 0; i < arguments.length; i++ ){\r\n                var Type       = arguments[ i ];\r\n                Type.attribute = Type.options = options;\r\n                Type.value     = value;\r\n                Type.Attribute = this;\r\n                Object.defineProperty( Type, 'has', {\r\n                    get : function(){\r\n                        // workaround for sinon.js and other libraries overriding 'has'\r\n                        return this._has || this.options();\r\n                    },\r\n                    set : function( value ){ this._has = value; }\r\n                } );\r\n            }\r\n        };\r\n    })()\r\n} );\r\n\r\nOptions.prototype.Attribute = Attribute;\r\nOptions.prototype.attribute = Options.prototype.options;\r\n\r\nfunction createOptions( spec ){\r\n    return new Options( spec );\r\n}\r\n\r\ncreateOptions.Type   = Attribute;\r\ncreateOptions.create = function( options, name ){\r\n    if( !( options && options instanceof Options ) ){\r\n        options = new Options( { typeOrValue : options } );\r\n    }\r\n\r\n    return options.createAttribute( name );\r\n};\r\n\r\nmodule.exports = createOptions;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/attribute.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\r\n\r\nvar _ = require( 'underscore' );\r\n\r\nmodule.exports = {\r\n    properties : {\r\n        validationError : {\r\n            enumerable : false,\r\n            get : function(){\r\n                var errors = this._validationError || ( this._validationError = new ValidationError() );\r\n                return errors.update( this );\r\n            }\r\n        }\r\n    },\r\n\r\n    _validationError : null,\r\n\r\n    validate : function(){},\r\n\r\n    _validateNested : function( errors ){\r\n        return 0;\r\n    },\r\n\r\n    getValidationError : function( key ){\r\n        var error = this.validationError;\r\n        return ( key ? error && error.nested[ key ] : error ) || null;\r\n    },\r\n\r\n    /**\r\n     * Extended Backbone API\r\n     * @param {string} key - nested object key\r\n     * @returns {boolean}\r\n     */\r\n    isValid : function( key ){\r\n        return !this.getValidationError( key );\r\n    },\r\n\r\n    _invalidate : function( options ){\r\n        var error;\r\n        if( options.validate && ( error = this.validationError ) ){\r\n            this.trigger( 'invalid', this, error, _.extend( { validationError : error }, options ) );\r\n            return true;\r\n        }\r\n    }\r\n};\r\n\r\nfunction ValidationError(){\r\n    this._changeToken = {};\r\n    this.length       = 0;\r\n    this.nested       = {};\r\n    this.error        = null;\r\n}\r\n\r\nValidationError.prototype.update = function( obj ){\r\n    if( this._changeToken !== obj._changeToken ){\r\n        this.length = obj._validateNested( this.nested = {} );\r\n\r\n        if( this.error = obj.validate( obj ) ){\r\n            this.length++;\r\n        }\r\n\r\n        this._changeToken = obj._changeToken;\r\n    }\r\n\r\n    return this.length ? this : null;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/validation-mixin.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\r\n * Backbone.js 1.2.3 REST implementation\r\n * (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n * Backbone may be freely distributed under the MIT license.\r\n *\r\n * With validation patches - NestedTypes validation semantic is applied. (c) Vlad Balin, 2015.\r\n */\r\n\r\nexports.Model = {\r\n    // Fetch the model from the server, merging the response with the model's\r\n    // local attributes. Any changed attributes will trigger a \"change\" event.\r\n    fetch : function( options ){\r\n        options         = _.extend( { parse : true }, options );\r\n        var model       = this;\r\n        var success     = options.success;\r\n        options.success = function( resp ){\r\n            var serverAttrs = options.parse ? model.parse( resp, options ) : resp;\r\n            model.set( serverAttrs, options );\r\n            if( model._invalidate( options ) ) return false;\r\n\r\n            if( success ) success.call( options.context, model, resp, options );\r\n            model.trigger( 'sync', model, resp, options );\r\n        };\r\n\r\n        wrapError( this, options );\r\n        return this.sync( 'read', this, options );\r\n    },\r\n\r\n    // Proxy `Backbone.sync` by default -- but override this if you need\r\n    // custom syncing semantics for *this* particular model.\r\n    sync : function(){\r\n        // Abort and pending IO request. Just one is allowed at the time.\r\n        var _this = this;\r\n        if( _this._xhr ){\r\n            _this._xhr.abort();\r\n        }\r\n\r\n        return this._xhr = exports.sync.apply( this, arguments )\r\n            .always( function(){ _this.xhr = void 0; });\r\n    },\r\n\r\n    // Set a hash of model attributes, and sync the model to the server.\r\n    // If the server returns an attributes hash that differs, the model's\r\n    // state will be `set` again.\r\n    save : function( key, val, options ){\r\n        // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n        var attrs;\r\n        if( key == null || typeof key === 'object' ){\r\n            attrs   = key;\r\n            options = val;\r\n        }\r\n        else{\r\n            (attrs = {})[ key ] = val;\r\n        }\r\n\r\n        options  = _.extend( { validate : true, parse : true }, options );\r\n        var wait = options.wait;\r\n\r\n        // If we're not waiting and attributes exist, save acts as\r\n        // `set(attr).save(null, opts)` with validation. Otherwise, check if\r\n        // the model will be valid when the attributes, if any, are set.\r\n        if( attrs && !wait ){\r\n            this.set( attrs, options );\r\n        }\r\n\r\n        if( this._invalidate( options ) ){\r\n            if( attrs && wait ) this.set( attrs, options );\r\n            return exports.errorPromise( this.validationError );\r\n        }\r\n\r\n        // After a successful server-side save, the client is (optionally)\r\n        // updated with the server-side state.\r\n        var model       = this;\r\n        var success     = options.success;\r\n        var attributes  = this.attributes;\r\n        options.success = function( resp ){\r\n            // Ensure attributes are restored during synchronous saves.\r\n            model.attributes = attributes;\r\n            var serverAttrs  = options.parse ? model.parse( resp, options ) : resp;\r\n            if( wait ) serverAttrs = _.extend( {}, attrs, serverAttrs );\r\n\r\n\r\n            if( serverAttrs ){\r\n                model.set( serverAttrs, options );\r\n                if( model._invalidate( options ) ) return false;\r\n            }\r\n\r\n            if( success ) success.call( options.context, model, resp, options );\r\n            model.trigger( 'sync', model, resp, options );\r\n        };\r\n        wrapError( this, options );\r\n\r\n        // Set temporary attributes if `{wait: true}` to properly find new ids.\r\n        if( attrs && wait ) this.attributes = _.extend( {}, attributes, attrs );\r\n\r\n        var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\r\n        if( method === 'patch' && !options.attrs ) options.attrs = attrs;\r\n        var xhr = this.sync( method, this, options );\r\n\r\n        // Restore attributes.\r\n        this.attributes = attributes;\r\n\r\n        return xhr;\r\n    },\r\n\r\n    // Destroy this model on the server if it was already persisted.\r\n    // Optimistically removes the model from its collection, if it has one.\r\n    // If `wait: true` is passed, waits for the server to respond before removal.\r\n    destroy : function( options ){\r\n        options     = options ? _.clone( options ) : {};\r\n        var model   = this;\r\n        var success = options.success;\r\n        var wait    = options.wait;\r\n\r\n        var destroy = function(){\r\n            model.stopListening();\r\n            model.trigger( 'destroy', model, model.collection, options );\r\n        };\r\n\r\n        options.success = function( resp ){\r\n            if( wait ) destroy();\r\n            if( success ) success.call( options.context, model, resp, options );\r\n            if( !model.isNew() ) model.trigger( 'sync', model, resp, options );\r\n        };\r\n\r\n        var xhr = false;\r\n        if( this.isNew() ){\r\n            _.defer( options.success );\r\n        }\r\n        else{\r\n            wrapError( this, options );\r\n            xhr = this.sync( 'delete', this, options );\r\n        }\r\n        if( !wait ) destroy();\r\n        return xhr;\r\n    },\r\n\r\n    urlRoot : '',\r\n\r\n    // Default URL for the model's representation on the server -- if you're\r\n    // using Backbone's restful methods, override this to change the endpoint\r\n    // that will be called.\r\n    url : function(){\r\n        var base =\r\n                _.result( this, 'urlRoot' ) ||\r\n                _.result( this.collection, 'url' ) ||\r\n                urlError();\r\n        if( this.isNew() ) return base;\r\n        var id = this.get( this.idAttribute );\r\n        return base.replace( /[^\\/]$/, '$&/' ) + encodeURIComponent( id );\r\n    }\r\n};\r\n\r\nexports.Collection = {\r\n    url : '',\r\n\r\n    // Fetch the default set of models for this collection, resetting the\r\n    // collection when they arrive. If `reset: true` is passed, the response\r\n    // data will be passed through the `reset` method instead of `set`.\r\n    fetch : function( options ){\r\n        options         = _.extend( { parse : true }, options );\r\n        var success     = options.success;\r\n        var collection  = this;\r\n        options.success = function( resp ){\r\n            var method = options.reset ? 'reset' : 'set';\r\n            collection[ method ]( resp, options );\r\n            if( collection._invalidate( options ) ) return false;\r\n\r\n            if( success ) success.call( options.context, collection, resp, options );\r\n            collection.trigger( 'sync', collection, resp, options );\r\n        };\r\n\r\n        wrapError( this, options );\r\n        return this.sync( 'read', this, options );\r\n    },\r\n\r\n    // Proxy `Backbone.sync` by default -- but override this if you need\r\n    // custom syncing semantics for *this* particular model.\r\n    sync : function(){\r\n        return exports.sync.apply( this, arguments );\r\n    }\r\n};\r\n\r\n// Throw an error when a URL is needed, and none is supplied.\r\nfunction urlError(){\r\n    throw new Error( 'A \"url\" property or function must be specified' );\r\n}\r\n\r\n// Wrap an optional error callback with a fallback error event.\r\nfunction wrapError( model, options ){\r\n    var error     = options.error;\r\n    options.error = function( resp ){\r\n        if( error ) error.call( options.context, model, resp, options );\r\n        model.trigger( 'error', model, resp, options );\r\n    };\r\n}\r\n\r\n// Backbone.sync\r\n// -------------\r\n\r\n// Override this function to change the manner in which Backbone persists\r\n// models to the server. You will be passed the type of request, and the\r\n// model in question. By default, makes a RESTful Ajax request\r\n// to the model's `url()`. Some possible customizations could be:\r\n//\r\n// * Use `setTimeout` to batch rapid-fire updates into a single request.\r\n// * Send up the models as XML instead of JSON.\r\n// * Persist models via WebSockets instead of Ajax.\r\n//\r\n// Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\r\n// as `POST`, with a `_method` parameter containing the true HTTP method,\r\n// as well as all requests with the body as `application/x-www-form-urlencoded`\r\n// instead of `application/json` with the model in a param named `model`.\r\n// Useful when interfacing with server-side languages like **PHP** that make\r\n// it difficult to read the body of `PUT` requests.\r\nexports.sync = function( method, model, options ){\r\n    var type = methodMap[ method ];\r\n    // Default options, unless specified.\r\n    _.defaults(options || (options = {}), {\r\n      emulateHTTP: Backbone.emulateHTTP,\r\n      emulateJSON: Backbone.emulateJSON\r\n    });\r\n\r\n    // Default JSON-request options.\r\n    var params = { type : type, dataType : 'json' };\r\n\r\n    // Ensure that we have a URL.\r\n    if( !options.url ){\r\n        params.url = _.result( model, 'url' ) || urlError();\r\n    }\r\n\r\n    // Ensure that we have the appropriate request data.\r\n    if( options.data == null && model && (method === 'create' || method === 'update' || method === 'patch') ){\r\n        params.contentType = 'application/json';\r\n        params.data        = JSON.stringify( options.attrs || model.toJSON( options ) );\r\n    }\r\n\r\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\r\n    if( options.emulateJSON ){\r\n        params.contentType = 'application/x-www-form-urlencoded';\r\n        params.data        = params.data ? { model : params.data } : {};\r\n    }\r\n\r\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\r\n    // And an `X-HTTP-Method-Override` header.\r\n    if( options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH') ){\r\n        params.type = 'POST';\r\n        if( options.emulateJSON ) params.data._method = type;\r\n        var beforeSend     = options.beforeSend;\r\n        options.beforeSend = function( xhr ){\r\n            xhr.setRequestHeader( 'X-HTTP-Method-Override', type );\r\n            if( beforeSend ) return beforeSend.apply( this, arguments );\r\n        };\r\n    }\r\n\r\n    // Don't process data on a non-GET request.\r\n    if( params.type !== 'GET' && !options.emulateJSON ){\r\n        params.processData = false;\r\n    }\r\n\r\n    // Pass along `textStatus` and `errorThrown` from jQuery.\r\n    var error     = options.error;\r\n    options.error = function( xhr, textStatus, errorThrown ){\r\n        options.textStatus  = textStatus;\r\n        options.errorThrown = errorThrown;\r\n        if( error ) error.call( options.context, xhr, textStatus, errorThrown );\r\n    };\r\n\r\n    // Make the request, allowing the user to override any Ajax options.\r\n    var xhr = options.xhr = exports.ajax( _.extend( params, options ) );\r\n    model.trigger( 'request', model, xhr, options );\r\n    return xhr;\r\n};\r\n\r\n// Map from CRUD to HTTP for our default `Backbone.sync` implementation.\r\nvar methodMap = {\r\n    'create' : 'POST',\r\n    'update' : 'PUT',\r\n    'patch'  : 'PATCH',\r\n    'delete' : 'DELETE',\r\n    'read'   : 'GET'\r\n};\r\n\r\n// Set the default implementation of `Backbone.ajax` to proxy through to `$`.\r\n// Override this if you'd like to use a different library.\r\nexports.ajax = function(){\r\n    return exports.$.ajax.apply( exports.$, arguments );\r\n};\r\n\r\nexports.errorPromise = function( error ){\r\n    var x = exports.$.Deferred();\r\n    x.reject( error );\r\n    return x;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/rest-mixin.js\n ** module id = 12\n ** module chunks = 0\n **/","var _ = require( 'underscore' );\r\n\r\nvar slice = Array.prototype.slice;\r\n\r\nexports.Model = {\r\n    pick    : function(){ return _.pick( this, slice.call( arguments ) ); },\r\n\r\n    escape : function( attr ){\r\n        return _.escape( this[ attr ] );\r\n    },\r\n\r\n    matches : function( attrs ){\r\n        return !!_.iteratee( attrs, this )( this );\r\n    }\r\n};\r\n\r\naddUnderscoreMethods( exports.Model, '_clonedProps', {\r\n    keys: 1, values: 1, pairs: 1, invert: 1,\r\n    omit: 0, chain: 1, isEmpty: 1\r\n});\r\n\r\n( exports.Model, [ 'keys', 'values', 'pairs', 'invert', 'chain', 'isEmpty' ] );\r\n\r\nexports.Collection = {};\r\n\r\naddUnderscoreMethods( exports.Collection, 'models', {\r\n    forEach  : 3, each : 3, map : 3, collect : 3, reduce : 4,\r\n    foldl    : 4, inject : 4, reduceRight : 4, foldr : 4, find : 3, findIndex : 3, findLastIndex : 3, detect : 3, filter : 3,\r\n    select   : 3, reject : 3, every : 3, all : 3, some : 3, any : 3, include : 3, includes : 3,\r\n    contains : 3, invoke : 0, max : 3, min : 3, toArray : 1, size : 1, first : 3,\r\n    head     : 3, take : 3, initial : 3, rest : 3, tail : 3, drop : 3, last : 3,\r\n    without  : 0, difference : 0, indexOf : 3, shuffle : 1, lastIndexOf : 3,\r\n    isEmpty  : 1, chain : 1, sample : 3, partition : 3, groupBy : 3, countBy : 3,\r\n    sortBy   : 3, indexBy : 3\r\n});\r\n\r\n\r\nfunction addUnderscoreMethods(Mixin, attribute, methods ) {\r\n    _.each(methods, function(length, method) {\r\n        if (_[method]) Mixin[method] = addMethod(length, method, attribute);\r\n    });\r\n}\r\n\r\n// Proxy Backbone class methods to Underscore functions, wrapping the model's\r\n// `attributes` object or collection's `models` array behind the scenes.\r\n//\r\n// collection.filter(function(model) { return model.get('age') > 10 });\r\n// collection.each(this.addView);\r\n//\r\n// `Function#apply` can be slow so we use the method's arg count, if we know it.\r\nfunction addMethod(length, method, attribute) {\r\n    switch (length) {\r\n        case 1: return function() {\r\n            return _[method](this[attribute]);\r\n        };\r\n        case 2: return function(value) {\r\n            return _[method](this[attribute], value);\r\n        };\r\n        case 3: return function(iteratee, context) {\r\n            var value = this[ attribute ],\r\n                callback = cb(iteratee, this);\r\n\r\n            return arguments.length > 1 ?\r\n                   _[method]( value, callback, context)\r\n                : _[method]( value, callback );\r\n        };\r\n        case 4: return function(iteratee, defaultVal, context) {\r\n            var value = this[ attribute ],\r\n                callback = cb(iteratee, this);\r\n\r\n            return arguments.length > 1 ?\r\n                   _[method]( value, callback, defaultVal, context )\r\n                : _[method](value, callback );\r\n        };\r\n        default: return function() {\r\n            var args = slice.call(arguments);\r\n            args.unshift(this[attribute]);\r\n            return _[method].apply(_, args);\r\n        };\r\n    }\r\n}\r\n\r\n// Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.\r\nfunction cb(iteratee, instance) {\r\n    if (_.isFunction(iteratee)) return iteratee;\r\n    if (_.isObject(iteratee) && !(iteratee instanceof instance.model )) return _.matches(iteratee);\r\n    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };\r\n    return iteratee;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/underscore-mixin.js\n ** module id = 13\n ** module chunks = 0\n **/","var _               = require( 'underscore' ),\r\n    Backbone        = require( './backbone+' ),\r\n    Model           = require( './model' ),\r\n    ValidationMixin = require( './validation-mixin' ),\r\n    RestMixin       = require( './rest-mixin' ).Collection,\r\n    UnderscoreMixin = require( './underscore-mixin' );\r\n\r\nvar Events   = Backbone.Events,\r\n    trigger1 = Events.trigger1,\r\n    trigger2 = Events.trigger2,\r\n    trigger3 = Events.trigger3;\r\n\r\nvar Commons               = require( './collections/commons' ),\r\n    toModel               = Commons.toModel,\r\n    dispose               = Commons.dispose,\r\n    ModelEventsDispatcher = Commons.ModelEventsDispatcher;\r\n\r\nvar Add          = require( './collections/add' ),\r\n    MergeOptions = Add.MergeOptions,\r\n    add          = Add.add,\r\n    set          = Add.set,\r\n    emptySet     = Add.emptySet;\r\n\r\nvar Remove     = require( './collections/remove' ),\r\n    removeOne  = Remove.removeOne,\r\n    removeMany = Remove.removeMany;\r\n\r\nCollectionProto = Backbone.Collection.prototype;\r\n\r\n// transactional wrapper for collections\r\nfunction transaction( func ){\r\n    return function(){\r\n        this.__changing++ || ( this._changed = false );\r\n\r\n        var res = func.apply( this, arguments );\r\n\r\n        if( !--this.__changing && this._changed ){\r\n            this._changeToken = {};\r\n            trigger1( this, 'changes', this );\r\n        }\r\n\r\n        return res;\r\n    };\r\n}\r\n\r\n// wrapper for standard collections modification methods\r\n// wrap call in transaction and convert singular args\r\nfunction method( method ){\r\n    return function( a_models, a_options ){\r\n        this.__changing++ || ( this._changed = false );\r\n\r\n        var options = a_options || {},\r\n            models  = options.parse ? this.parse( a_models, options ) : a_models;\r\n\r\n        var res = models ? (\r\n            models instanceof Array ?\r\n            method.call( this, models, options )\r\n                : method.call( this, [ models ], options )[ 0 ]\r\n        ) : method.call( this, [], options );\r\n\r\n        if( !--this.__changing && this._changed ){\r\n            this._changeToken = {};\r\n            options.silent || trigger1( this, 'changes', this );\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\nfunction handleChange(){\r\n    if( this.__changing ){\r\n        this._changed = true;\r\n    }\r\n    else{\r\n        this._changeToken = {};\r\n        trigger1( this, 'changes', this );\r\n    }\r\n}\r\n\r\nfunction SilentOptions( a_options ){\r\n    var options = a_options || {};\r\n    this.parse  = options.parse;\r\n    this.sort   = options.sort;\r\n}\r\n\r\nSilentOptions.prototype.silent = true;\r\n\r\nfunction CreateOptions( options, collection ){\r\n    MergeOptions.call( this, options, collection );\r\n    if( options ){\r\n        _.defaults( this, options );\r\n    }\r\n}\r\n\r\nmodule.exports = Backbone.Collection.extend( {\r\n    mixins : [ ValidationMixin, RestMixin, UnderscoreMixin.Collection ],\r\n\r\n    triggerWhenChanged : 'changes',\r\n    _listenToChanges   : 'update change reset',\r\n    __class            : 'Collection',\r\n\r\n    model : Model,\r\n\r\n    _owner : null,\r\n    _store : null,\r\n\r\n    __changing   : 0,\r\n    _changed     : false,\r\n    _changeToken : {},\r\n\r\n    _dispatcher : null,\r\n\r\n    properties : {\r\n        length : {\r\n            enumerable : false,\r\n            get : function(){\r\n                return this.models.length;\r\n            }\r\n        }\r\n    },\r\n\r\n    _validateNested : function( errors ){\r\n        var models = this.models,\r\n            length = 0;\r\n\r\n        for( var i = 0; i < models.length; i++ ){\r\n            var model = models[ i ],\r\n                error = model.validationError;\r\n\r\n            if( error ){\r\n                errors[ model.cid ] = error;\r\n                length++;\r\n            }\r\n        }\r\n\r\n        return length;\r\n    },\r\n\r\n    modelId : function( attrs ){\r\n        return attrs[ this.model.prototype.idAttribute || 'id' ];\r\n    },\r\n\r\n    constructor : function( models, a_options ){\r\n        var options = a_options || {};\r\n\r\n        this.__changing   = 0;\r\n        this._changed     = false;\r\n        this._changeToken = {};\r\n        this._owner       = this._store = null;\r\n\r\n        this.model      = options.model || this.model;\r\n        if (options.comparator !== void 0) this.comparator = options.comparator;\r\n\r\n        this.models = [];\r\n        this._byId  = {};\r\n\r\n        if( models ) this.reset( models, new SilentOptions( options ) );\r\n\r\n        this.listenTo( this, this._listenToChanges, handleChange );\r\n\r\n        this.initialize.apply( this, arguments );\r\n    },\r\n\r\n    getStore : function(){\r\n        return this._store || ( this._store = this._owner ? this._owner.getStore() : this._defaultStore );\r\n    },\r\n\r\n    sync : function(){\r\n        return this.getStore().sync.apply( this, arguments );\r\n    },\r\n\r\n    isValid : function( options ){\r\n        return this.every( function( model ){\r\n            return model.isValid( options );\r\n        } );\r\n    },\r\n\r\n    // Toggle model in collection\r\n    toggle : function( model, a_next ){\r\n        var prev = Boolean( this.get( model ) ),\r\n            next = a_next === void 0 ? !prev : Boolean( a_next );\r\n\r\n        if( prev !== next ){\r\n            if( prev ){\r\n                this.remove( model );\r\n            }\r\n            else{\r\n                this.add( model );\r\n            }\r\n        }\r\n\r\n        return next;\r\n    },\r\n\r\n    get : function( obj ){\r\n        if( obj == null ){ return void 0; }\r\n\r\n        if( typeof obj === 'object' ){\r\n            return this._byId[ obj[ this.model.prototype.idAttribute ] ] || this._byId[ obj.cid ];\r\n        }\r\n\r\n        return this._byId[ obj ];\r\n    },\r\n\r\n    set : method( function( models, options ){\r\n        return this.length ?\r\n               set( this, models, options ) :\r\n               emptySet( this, models, options );\r\n    } ),\r\n\r\n    reset : method( function( a_models, a_options ){\r\n        var options        = a_options || {},\r\n            previousModels = dispose( this );\r\n\r\n        var models = emptySet( this, a_models, new SilentOptions( options ) );\r\n\r\n        options.silent || trigger2( this, 'reset', this, _.defaults( { previousModels : previousModels }, options ) );\r\n\r\n        return models;\r\n    } ),\r\n\r\n    // Add a model to the end of the collection.\r\n    push: function(model, options) {\r\n        return this.add(model, _.extend({ at: this.length }, options ));\r\n    },\r\n\r\n    add : method( function( models, options ){\r\n        return this.length ?\r\n               add( this, models, options )\r\n            : emptySet( this, models, options );\r\n    } ),\r\n\r\n    sort : transaction( CollectionProto.sort ),\r\n\r\n// Methods with singular fast-path\r\n//------------------------------------------------\r\n    // Remove a model, or a list of models from the set.\r\n    remove : transaction( function( a_models, a_options ){\r\n        var options = a_options || {};\r\n\r\n        if( a_models ){\r\n            return a_models instanceof Array ?\r\n                   removeMany( this, a_models, options )\r\n                : removeOne( this, a_models, options );\r\n        }\r\n    } ),\r\n\r\n    // TODO: move to REST mixin\r\n    create : function( a_model, a_options ){\r\n        var options = new CreateOptions( a_options, this ),\r\n            model   = toModel( this, a_model, options );\r\n\r\n        if( !options.wait ) add( this, [ model ], options );\r\n        var collection  = this;\r\n        var success     = options.success;\r\n        options.success = function( model, resp, callbackOpts ){\r\n            if( options.wait ) add( collection, [ model ], callbackOpts );\r\n            if( success ) success.call( callbackOpts.context, model, resp, callbackOpts );\r\n        };\r\n\r\n        model.save( null, options );\r\n        return model;\r\n    },\r\n\r\n    _onModelEvent : function( event, model, collection, options ){\r\n        // lazy initialize dispatcher...\r\n        var dispatcher = this._dispatcher || ( this._dispatcher = new ModelEventsDispatcher( this.model ) ),\r\n            handler    = dispatcher[ event ] || trigger3;\r\n\r\n        handler( this, event, model, collection, options );\r\n    },\r\n\r\n    at : function( index ){\r\n        if( index < 0 ) index += this.length;\r\n        return this.models[ index ];\r\n    },\r\n\r\n    deepClone : function(){ return this.clone( { deep : true } ); },\r\n\r\n    clone : function( options ){\r\n        var models = options && options.deep ?\r\n                     this.map( function( model ){\r\n                         return model.clone( options );\r\n                     } ) : this.models;\r\n\r\n        return new this.constructor( models, { model : this.model, comparator : this.comparator } );\r\n    },\r\n\r\n    transaction : function( func, self, args ){\r\n        return transaction( func ).apply( self || this, args );\r\n    },\r\n\r\n    getModelIds : function(){ return _.pluck( this.models, 'id' ); },\r\n\r\n    createSubset : function( models, options ){\r\n        var SubsetOf = this.constructor.subsetOf( this ).createAttribute().type;\r\n        var subset   = new SubsetOf( models, options );\r\n        subset.resolve( this );\r\n        return subset;\r\n    }\r\n}, {\r\n    // Cache for subsetOf collection subclass.\r\n    __subsetOf : null,\r\n    defaults   : function( attrs ){\r\n        return this.prototype.model.extend( { defaults : attrs } ).Collection;\r\n    },\r\n    extend     : function(){\r\n        // Need to subsetOf cache when extending the collection\r\n        var This        = Backbone.Collection.extend.apply( this, arguments );\r\n        This.__subsetOf = null;\r\n        return This;\r\n    }\r\n} );\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/collection.js\n ** module id = 14\n ** module chunks = 0\n **/","/**\r\n * Helper functions\r\n */\r\n\r\nvar Events   = require( '../backbone+' ).Events,\r\n    trigger3 = Events.trigger3,\r\n    trigger2 = Events.trigger2,\r\n    onAll    = Events.onAll,\r\n    offAll    = Events.offAll;\r\n\r\nvar _ = require( 'underscore' );\r\n\r\nvar silence = { silent : true };\r\n\r\nmodule.exports = {\r\n    SilentOptions : SilentOptions,\r\n    silence       : silence,\r\n\r\n    addReference    : addReference,\r\n    removeReference : removeReference,\r\n\r\n    addIndex    : addIndex,\r\n    removeIndex : removeIndex,\r\n\r\n    dispose : dispose,\r\n\r\n    toModel : toModel,\r\n\r\n    ModelEventsDispatcher : ModelEventsDispatcher\r\n};\r\n\r\nfunction SilentOptions( a_options ){\r\n    var options = a_options || {};\r\n    this.parse  = options.parse;\r\n    this.sort   = options.sort;\r\n}\r\n\r\nSilentOptions.prototype = silence;\r\n\r\n\r\n// Ownership and events subscription\r\nfunction addReference( collection, model ){\r\n    model.collection || ( model.collection = collection );\r\n    onAll( model, collection._onModelEvent, collection );\r\n    return model;\r\n}\r\n\r\nfunction removeReference( collection, model ){\r\n    if( collection === model.collection ){\r\n        model.collection = void 0;\r\n    }\r\n\r\n    offAll( model, collection._onModelEvent, collection );\r\n}\r\n\r\nfunction dispose( collection ){\r\n    var models = collection.models;\r\n\r\n    collection.models = [];\r\n    collection._byId  = {};\r\n\r\n    for( var i = 0; i < models.length; i++ ){\r\n        removeReference( collection, models[ i ] );\r\n    }\r\n\r\n    return models;\r\n}\r\n\r\n// Index management\r\nfunction addIndex( _byId, model ){\r\n    _byId[ model.cid ] = model;\r\n    var id             = model.id;\r\n    if( id != null ){\r\n        _byId[ id ] = model;\r\n    }\r\n}\r\n\r\nfunction removeIndex( _byId, model ){\r\n    delete _byId[ model.cid ];\r\n    var id = model.id;\r\n    if( id != null ){\r\n        delete _byId[ id ];\r\n    }\r\n}\r\n\r\nfunction ModelOptions( options, collection ){\r\n    this.parse      = options.parse;\r\n    this.collection = collection;\r\n}\r\n\r\n// convert argument to model. Return false if fails.\r\nfunction toModel( collection, attrs, a_options ){\r\n    // Only subtype of current collection model is allowed\r\n    var Model = collection.model;\r\n    if( attrs instanceof Model ) return attrs;\r\n\r\n    var options = new ModelOptions( a_options, collection );\r\n\r\n    // Use abstract class factory if defined.\r\n    return Model.create ? Model.create( attrs, options ) : new Model( attrs, options );\r\n}\r\n\r\nfunction ModelEventsDispatcher( model ){\r\n    this[ 'change:' + model.prototype.idAttribute ] = _updateIdAttr;\r\n}\r\n\r\nModelEventsDispatcher.prototype = {\r\n    change  : trigger2,\r\n    sync    : trigger2,\r\n    add     : _triggerWhenRelevant,\r\n    remove  : _triggerWhenRelevant,\r\n    destroy : function( self, event, model, collection, options ){\r\n        self.remove( model, options );\r\n        trigger3( self, event, model, collection, options );\r\n    }\r\n};\r\n\r\nfunction _triggerWhenRelevant( self, event, model, collection, options ){\r\n    if( collection === self ){\r\n        trigger3( self, event, model, collection, options );\r\n    }\r\n}\r\n\r\nfunction _updateIdAttr( self, event, model, collection, options ){\r\n    var _byId = self._byId;\r\n\r\n    _byId[ model._previousAttributes[ model.idAttribute ] ] = void 0;\r\n    var id                                            = model.id;\r\n    id == null || ( _byId[ id ] = model );\r\n\r\n    trigger3( self, event, model, collection, options );\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/collections/commons.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\r\n * Add models to collection, if models with the same id doesn't belong to collection\r\n * options:\r\n *  - silent = false\r\n *  - sort = true\r\n *  - at = null\r\n *  - pass through other options\r\n */\r\nvar Events   = require( '../backbone+' ).Events,\r\n    trigger2 = Events.trigger2,\r\n    trigger3 = Events.trigger3;\r\n\r\nvar Commons         = require( './commons' ),\r\n    addIndex        = Commons.addIndex,\r\n    addReference    = Commons.addReference,\r\n    removeReference = Commons.removeReference,\r\n    toModel         = Commons.toModel,\r\n    silence         = Commons.silence;\r\n\r\nvar MergeOptions = exports.MergeOptions = function( a_options, collection ){\r\n    var options = a_options || {};\r\n\r\n    this.silent = options.silent;\r\n    this.parse  = options.parse;\r\n    this.merge  = options.merge;\r\n\r\n    // at option\r\n    var at = options.at;\r\n    if( at != null ){\r\n        this.sort = false;\r\n\r\n        // if at is given, it overrides sorting option...\r\n        at = +at;\r\n        if( at < 0 ) at += collection.length + 1;\r\n        if( at < 0 ) at = 0;\r\n        if( at > collection.length ) at = collection.length;\r\n\r\n        this.at    = at;\r\n        this.index = null;\r\n    }\r\n    else{\r\n        this.sort = collection.comparator && options.sort !== false;\r\n    }\r\n};\r\n\r\nMergeOptions.prototype = {\r\n    notify : function( collection, added, sorted ){\r\n        var at       = this.at,\r\n            inserted = at != null;\r\n\r\n        for( var i = 0; i < added.length; i++ ){\r\n            var model = added[ i ];\r\n            if( inserted ) this.index = at++;\r\n            trigger3( model, 'add', model, collection, this );\r\n        }\r\n\r\n        sorted && trigger2( collection, 'sort', collection, this );\r\n\r\n        if( added.length ){\r\n            trigger2( collection, 'update', collection, this );\r\n        }\r\n    }\r\n};\r\n\r\nexports.add = function add( collection, items, a_options ){\r\n    var options = new MergeOptions( a_options, collection );\r\n\r\n    var _changed        = collection._changed;\r\n    collection._changed = false;\r\n\r\n    var added = _append( collection, items, options );\r\n\r\n    var changed  = collection._changed || added.length,\r\n        needSort = options.sort && changed;\r\n\r\n    collection._changed = changed || _changed;\r\n\r\n    if( options.at != null ){\r\n        _move( collection.models, options.at, added );\r\n    }\r\n    else if( needSort ){\r\n        collection.sort( silence );\r\n    }\r\n\r\n    options.silent || options.notify( collection, added, needSort );\r\n\r\n    return added;\r\n};\r\n\r\n// append data to model and index\r\nfunction _append( collection, a_items, a_options ){\r\n    var models      = collection.models,\r\n        _byId       = collection._byId,\r\n        merge       = a_options.merge,\r\n        parse       = a_options.parse,\r\n        idAttribute = collection.model.prototype.idAttribute,\r\n        prevLength = models.length;\r\n\r\n    for( var i = 0; i < a_items.length; i++ ){\r\n        var item  = a_items[ i ],\r\n            model = item ? _byId[ item[ idAttribute ] ] || _byId[ item.cid ] : null;\r\n\r\n        if( model ){\r\n            if( merge && item !== model ){\r\n                var attrs = item.attributes || item;\r\n                if( parse ) attrs = model.parse( attrs, a_options );\r\n                model.set( attrs, a_options );\r\n            }\r\n        }\r\n        else{\r\n            model = toModel( collection, item, a_options );\r\n\r\n            models.push( model );\r\n            addReference( collection, model );\r\n            addIndex( _byId, model );\r\n        }\r\n    }\r\n\r\n    return models.slice( prevLength );\r\n}\r\n\r\nfunction _move( source, at, added ){\r\n    for( var j = source.length - 1, i = j - added.length; i >= at; i--, j-- ){\r\n        source[ j ] = source[ i ];\r\n    }\r\n\r\n    for( i = 0, j = at; i < added.length; i++, j++ ){\r\n        source[ j ] = added[ i ];\r\n    }\r\n}\r\n\r\n\r\nexports.emptySet = function emptySet( collection, items, a_options, silent ){\r\n    var options = new MergeOptions( a_options, collection );\r\n\r\n    if( silent ){\r\n        options.silent = silent;\r\n    }\r\n\r\n    var added = _reallocateEmpty( collection, items, options );\r\n\r\n    collection._changed || ( collection._changed = added.length );\r\n\r\n    var needSort = options.sort && added.length;\r\n    if( needSort ) collection.sort( silence );\r\n\r\n    options.silent || options.notify( collection, added, needSort );\r\n\r\n    return added;\r\n};\r\n\r\nfunction _reallocateEmpty( self, source, options ){\r\n    var len         = source ? source.length : 0,\r\n        models      = Array( len ),\r\n        _byId       = {},\r\n        idAttribute = self.model.prototype.idAttribute;\r\n\r\n    for( var i = 0, j = 0; i < len; i++ ){\r\n        var src = source[ i ];\r\n\r\n        if( src && ( _byId[ src[ idAttribute ] ] || _byId[ src.cid ] ) ){\r\n            continue;\r\n        }\r\n\r\n        var model = toModel( self, src, options );\r\n\r\n        addReference( self, model );\r\n        models[ j++ ] = model;\r\n        addIndex( _byId, model );\r\n\r\n    }\r\n\r\n    models.length = j;\r\n    self._byId    = _byId;\r\n\r\n    return self.models = models;\r\n}\r\n\r\nexports.set = function set( collection, items, a_options ){\r\n    var options = new MergeOptions( a_options, collection );\r\n\r\n    var _changed        = collection._changed;\r\n    collection._changed = false;\r\n\r\n    var previous = collection.models,\r\n        added    = _reallocate( collection, items, options );\r\n\r\n    var removed        = collection.models.length - added.length < previous.length,\r\n        addedOrChanged = collection._changed || added.length,\r\n        needSort       = options.sort && addedOrChanged;\r\n\r\n    collection._changed = addedOrChanged || removed || _changed;\r\n\r\n    if( needSort ){ collection.sort( silence ) }\r\n\r\n    if( removed ){\r\n        _garbageCollect( collection, previous, options );\r\n    }\r\n\r\n    // Unless silenced, it's time to fire all appropriate add/sort events.\r\n    options.silent || options.notify( collection, added, needSort );\r\n\r\n    // Return the added (or merged) model (or models).\r\n    return collection.models;\r\n};\r\n\r\n// Remove references from models missing in collection's index\r\n// Send 'remove' events if no silent\r\nfunction _garbageCollect( collection, previous, options ){\r\n    var _byId  = collection._byId,\r\n        silent = options.silent;\r\n\r\n    // Filter out removed models and remove them from the index...\r\n    for( var i = 0; i < previous.length; i++ ){\r\n        var model = previous[ i ];\r\n\r\n        if( !_byId[ model.cid ] ){\r\n            silent || trigger3( model, 'remove', model, collection, options );\r\n            removeReference( collection, model );\r\n        }\r\n    }\r\n}\r\n\r\n// reallocate model and index\r\nfunction _reallocate( self, source, options ){\r\n    var models      = Array( source.length ),\r\n        _byId       = {},\r\n        merge       = options.merge == null ? true : options.merge,\r\n        _prevById   = self._byId,\r\n        idAttribute = self.model.prototype.idAttribute,\r\n        toAdd       = [];\r\n\r\n    // for each item in source set...\r\n    for( var i = 0, j = 0; i < source.length; i++ ){\r\n        var item  = source[ i ],\r\n            model = null;\r\n\r\n        if( item ){\r\n            var id  = item[ idAttribute ],\r\n                cid = item.cid;\r\n\r\n            if( _byId[ id ] || _byId[ cid ] ) continue;\r\n\r\n            model = _prevById[ id ] || _prevById[ cid ];\r\n        }\r\n\r\n        if( model ){\r\n            if( merge && item !== model ){\r\n                var attrs = item.attributes || item;\r\n                if( options.parse ) attrs = model.parse( attrs, options );\r\n                model.set( attrs, options );\r\n            }\r\n        }\r\n        else{\r\n            model = toModel( self, item, options );\r\n            addReference( self, model );\r\n            toAdd.push( model );\r\n        }\r\n\r\n        models[ j++ ] = model;\r\n        addIndex( _byId, model );\r\n    }\r\n\r\n    models.length = j;\r\n    self.models   = models;\r\n    self._byId    = _byId;\r\n\r\n    return toAdd;\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/collections/add.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\r\n * Remove single element from collection\r\n * el: ModelId | ModelCid | Model | ModelAttrs\r\n * Options:\r\n *      - silent : Boolean = false\r\n */\r\n\r\nvar Commons         = require( './commons' ),\r\n    removeIndex     = Commons.removeIndex,\r\n    removeReference = Commons.removeReference;\r\n\r\nvar Events   = require( '../backbone+' ).Events,\r\n    trigger3 = Events.trigger3,\r\n    trigger2 = Events.trigger2;\r\n\r\nfunction RemoveOptions( options ){\r\n    this.silent = options.silent;\r\n}\r\n\r\nRemoveOptions.prototype = {\r\n    add    : false,\r\n    remove : true,\r\n    merge  : false\r\n};\r\n\r\nexports.removeOne = function removeOne( collection, el, a_options ){\r\n    var options = new RemoveOptions( a_options );\r\n\r\n    var model = collection.get( el );\r\n    if( model ){\r\n        var models = collection.models,\r\n            // TODO: for sorted collection, find element with binary search.\r\n            at     = _.indexOf( models, model ),\r\n            silent = options.silent;\r\n\r\n        models.splice( at, 1 );\r\n\r\n        removeIndex( collection._byId, model );\r\n\r\n        silent || trigger3( model, 'remove', model, collection, options );\r\n\r\n        removeReference( collection, model );\r\n\r\n        silent || trigger2( collection, 'update', collection, options );\r\n\r\n        return model;\r\n    }\r\n};\r\n\r\n/** Optimized for removing many elements\r\n * 1. Remove elements from the index, checking for duplicates\r\n * 2. Create new models array matching index\r\n * 3. Send notifications and remove references\r\n */\r\nexports.removeMany = function removeMany( collection, toRemove, a_options ){\r\n    var options = new RemoveOptions( a_options );\r\n\r\n    var removed = _removeFromIndex( collection, toRemove );\r\n\r\n    _reallocate( collection, removed.length );\r\n\r\n    _removeModels( collection, removed, options );\r\n\r\n    options.silent || !removed.length || trigger2( collection, 'update', collection, options );\r\n\r\n    return removed;\r\n};\r\n\r\n// remove models from the index...\r\nfunction _removeFromIndex( collection, toRemove ){\r\n    var removed = Array( toRemove.length ),\r\n        _byId   = collection._byId;\r\n\r\n    for( var i = 0, j = 0; i < toRemove.length; i++ ){\r\n        var model = collection.get( toRemove[ i ] );\r\n        if( model ){\r\n            removed[ j++ ] = model;\r\n            removeIndex( _byId, model );\r\n        }\r\n    }\r\n\r\n    removed.length = j;\r\n\r\n    return removed;\r\n}\r\n\r\n// Allocate new models array removing models not present in the index.\r\nfunction _reallocate( collection, removed ){\r\n    var prev   = collection.models,\r\n        models = collection.models = Array( prev.length - removed ),\r\n        _byId = collection._byId;\r\n\r\n    for( var i = 0, j = 0; i < prev.length; i++ ){\r\n        var model = prev[ i ];\r\n\r\n        if( _byId[ model.cid ] ){\r\n            models[ j++ ] = model;\r\n        }\r\n    }\r\n\r\n    models.length = j;\r\n}\r\n\r\nfunction _removeModels( collection, removed, options ){\r\n    var silent = options.silent;\r\n    for( var i = 0; i < removed.length; i++ ){\r\n        var model = removed[ i ];\r\n        silent || trigger3( model, 'remove', model, collection, options );\r\n        removeReference( collection, model );\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/collections/remove.js\n ** module id = 17\n ** module chunks = 0\n **/","// Nested Relations\r\n//=================\r\n\r\nvar bbVersion  = require( './backbone+' ).VERSION,\r\n    attribute  = require( './attribute' ),\r\n    error      = require( './errors' ),\r\n    Collection = require( './collection' ),\r\n    _          = require( 'underscore' );\r\n\r\nfunction parseReference( collectionRef ){\r\n    switch( typeof collectionRef ){\r\n        case 'function' :\r\n            return collectionRef;\r\n        case 'object'   :\r\n            return function(){ return collectionRef; };\r\n        case 'string'   :\r\n            var path = collectionRef\r\n                .replace( /\\^/g, 'getOwner().' )\r\n                .replace( /^\\~/, 'store.' )\r\n                .replace( /^store\\.(\\w+)/, 'getStore().get(\"$1\")' );\r\n\r\n            return new Function( 'return this.' + path );\r\n    }\r\n}\r\n\r\nexports.parseReference = parseReference;\r\n\r\nvar TakeAttribute = attribute.Type.extend( {\r\n    clone     : function( value ){ return value; },\r\n    isChanged : function( a, b ){ return a !== b; },\r\n    set       : function( value, name ){\r\n        if( !value ) return null;\r\n\r\n        error.hardRefNotAssignable( this, name, value );\r\n    },\r\n\r\n    _update : function( val, options, model, attr ){\r\n        return this.delegateEvents( this.cast( val, options, model, attr ), options, model, attr );\r\n    }\r\n} );\r\n\r\nexports.take = function( reference ){\r\n    var getMaster = parseReference( reference );\r\n\r\n    var options = attribute( {\r\n        value  : null,\r\n        toJSON : false,\r\n        type   : this,\r\n        get    : function( ref, name ){\r\n            if( !ref ){\r\n                // Resolve reference.\r\n                var value = getMaster.call( this );\r\n\r\n                if( value ){\r\n                    // Silently update attribute with object from master.\r\n                    // Subscribe for all events...\r\n                    var attrSpec = this.__attributes[ name ];\r\n                    return this.attributes[ name ] = attrSpec._update( value, {}, this, name );\r\n                }\r\n            }\r\n\r\n            return ref;\r\n        }\r\n    } );\r\n\r\n    options.Attribute = TakeAttribute;\r\n    return options;\r\n};\r\n\r\nexports.from = function( masterCollection ){\r\n    var getMaster = parseReference( masterCollection );\r\n\r\n    function clone( value ){\r\n        return value && typeof value === 'object' ? value.id : value;\r\n    }\r\n\r\n    var ModelRefAttribute = attribute.Type.extend( {\r\n        toJSON : clone,\r\n        clone  : clone,\r\n        validate : function( model, value, name ){},\r\n        isChanged : function( a, b ){\r\n            // refs are equal when their id is equal.\r\n            var aId = a && ( a.id == null ? a : a.id ),\r\n                bId = b && ( b.id == null ? b : b.id );\r\n\r\n            return aId !== bId;\r\n        },\r\n\r\n        get : function( objOrId, name ){\r\n            if( typeof objOrId !== 'object' ){\r\n                // Resolve reference.\r\n                var master = getMaster.call( this );\r\n\r\n                if( master && master.length ){\r\n                    // Silently update attribute with object form master.\r\n                    objOrId                 = master.get( objOrId ) || null;\r\n                    this.attributes[ name ] = objOrId;\r\n\r\n                    // Subscribe for events manually. delegateEvents won't be invoked.\r\n                    var attrSpec = this.__attributes[ name ];\r\n                    objOrId && attrSpec.events && this.listenTo( objOrId, attrSpec.events );\r\n                }\r\n                else{\r\n                    objOrId = null;\r\n                }\r\n            }\r\n\r\n            return objOrId;\r\n        }\r\n    } );\r\n\r\n    var options       = attribute( { value : null } );\r\n    options.Attribute = ModelRefAttribute; //todo: consider moving this to the attrSpec\r\n    return options;\r\n};\r\n\r\nvar CollectionProto = Collection.prototype;\r\n\r\nfunction adjustOptions( models, options ){\r\n    var adjust = { merge : false };\r\n\r\n    if( models ){\r\n        if( models instanceof Array && models.length && typeof models[ 0 ] !== 'object' ){\r\n            adjust.merge = adjust.parse = true;\r\n        }\r\n    }\r\n\r\n    return _.defaults( adjust, options );\r\n}\r\n\r\nvar refsCollectionSpec = {\r\n    _listenToChanges : 'update reset', // don't bubble changes from models\r\n    __class          : 'Collection.subsetOf',\r\n\r\n    resolvedWith : null,\r\n    refs         : null,\r\n\r\n    toJSON : function(){\r\n        return this.refs || _.pluck( this.models, 'id' );\r\n    },\r\n\r\n    clone : function( options ){\r\n        var copy          = CollectionProto.clone.call( this, _.omit( options, 'deep' ) );\r\n        copy.resolvedWith = this.resolvedWith;\r\n        copy.refs         = this.refs;\r\n\r\n        return copy;\r\n    },\r\n\r\n    parse : function( raw ){\r\n        var models = [];\r\n\r\n        if( this.resolvedWith ){\r\n            models = _.compact( _.map( raw, function( id ){\r\n                return this.resolvedWith.get( id );\r\n            }, this ) );\r\n        }\r\n        else{\r\n            this.refs = raw;\r\n        }\r\n\r\n        return models;\r\n    },\r\n\r\n    toggle : function( modelOrId, val ){\r\n        var model = this.resolvedWith.get( modelOrId );\r\n        return CollectionProto.toggle.call( this, model, val );\r\n    },\r\n\r\n    addAll : function(){\r\n        this.reset( this.resolvedWith.models );\r\n    },\r\n\r\n    removeAll : function(){\r\n        this.reset();\r\n    },\r\n\r\n    toggleAll : function(){\r\n        if( this.length ){\r\n            this.removeAll();\r\n        }\r\n        else{\r\n            this.addAll();\r\n        }\r\n    },\r\n\r\n    getModelIds : function(){ return this.refs || _.pluck( this.models, 'id' ); },\r\n\r\n    justOne : function( arg ){\r\n        var model = arg instanceof Backbone.Model ? arg : this.resolvedWith.get( arg );\r\n        this.set( [ model ] );\r\n    },\r\n\r\n    set : function( models, options ){\r\n        return CollectionProto.set.call( this, models, adjustOptions( models, options ) );\r\n    },\r\n\r\n    add : function( models, options ){\r\n        return CollectionProto.add.call( this, models, adjustOptions( models, options ) );\r\n    },\r\n\r\n    reset : function( models, options ){\r\n        return CollectionProto.reset.call( this, models, adjustOptions( models, options ) );\r\n    },\r\n\r\n    resolve : function( collection ){\r\n        if( collection && collection.length ){\r\n            this.resolvedWith = collection;\r\n\r\n            if( this.refs ){\r\n                this.reset( this.refs, { silent : true } );\r\n                this.refs = null;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nexports.subsetOf = function( masterCollection ){\r\n    var SubsetOf  = this.__subsetOf || ( this.__subsetOf = this.extend( refsCollectionSpec ) );\r\n    var getMaster = parseReference( masterCollection );\r\n\r\n    return attribute( {\r\n        type : SubsetOf,\r\n        validate : function( model, value, name ){},\r\n        get : function( refs ){\r\n            !refs || refs.resolvedWith || refs.resolve( getMaster.call( this ) );\r\n            return refs;\r\n        }\r\n    } );\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/relations.js\n ** module id = 18\n ** module chunks = 0\n **/","// Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\r\n// (c) 2011 Colin Snover <http://zetafleet.com>\r\n// Released under MIT license.\r\n\r\n// Attribute Type definitions for core JS types\r\n// ============================================\r\nvar attribute  = require( './attribute' ),\r\n    modelSet   = require( './modelset' ),\r\n    Model      = require( './model' ),\r\n    errors     = require( './errors' ),\r\n    Collection = require( './collection' );\r\n\r\n// Constructors Attribute\r\n// ----------------\r\nattribute.Type.extend( {\r\n    cast : function( value ){\r\n        return value == null || value instanceof this.type ? value : new this.type( value );\r\n    },\r\n\r\n    clone : function( value, options ){\r\n        // delegate to clone function or deep clone through serialization\r\n        return value.clone ? value.clone( value, options ) : this.cast( JSON.parse( JSON.stringify( value ) ) );\r\n    }\r\n} ).attach( Function.prototype );\r\n\r\n// Date Attribute\r\n// ----------------------\r\nvar numericKeys    = [ 1, 4, 5, 6, 7, 10, 11 ],\r\n    msDatePattern  = /\\/Date\\(([0-9]+)\\)\\//,\r\n    isoDatePattern = /^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\r\n\r\nfunction parseDate( date ){\r\n    var msDate, timestamp, struct, minutesOffset = 0;\r\n\r\n    if( msDate = msDatePattern.exec( date ) ){\r\n        timestamp = Number( msDate[ 1 ] );\r\n    }\r\n    else if( ( struct = isoDatePattern.exec( date )) ){\r\n        // avoid NaN timestamps caused by undefined values being passed to Date.UTC\r\n        for( var i = 0, k; ( k = numericKeys[ i ] ); ++i ){\r\n            struct[ k ] = +struct[ k ] || 0;\r\n        }\r\n\r\n        // allow undefined days and months\r\n        struct[ 2 ] = (+struct[ 2 ] || 1) - 1;\r\n        struct[ 3 ] = +struct[ 3 ] || 1;\r\n\r\n        if( struct[ 8 ] !== 'Z' && struct[ 9 ] !== undefined ){\r\n            minutesOffset = struct[ 10 ] * 60 + struct[ 11 ];\r\n\r\n            if( struct[ 9 ] === '+' ){\r\n                minutesOffset = 0 - minutesOffset;\r\n            }\r\n        }\r\n\r\n        timestamp =\r\n            Date.UTC( struct[ 1 ], struct[ 2 ], struct[ 3 ], struct[ 4 ], struct[ 5 ] + minutesOffset, struct[ 6 ],\r\n                struct[ 7 ] );\r\n    }\r\n    else{\r\n        timestamp = Date.parse( date );\r\n    }\r\n\r\n    return timestamp;\r\n}\r\n\r\nattribute.Type.extend( {\r\n    cast : function( value ){\r\n        return value == null || value instanceof Date ? value :\r\n               new Date( typeof value === 'string' ? parseDate( value ) : value )\r\n    },\r\n\r\n    validate : function( model, value, name ){\r\n        if( isNaN( +value ) ) return 'Invalid Date';\r\n    },\r\n\r\n    toJSON : function( value ){ return value && value.toJSON(); },\r\n\r\n    isChanged : function( a, b ){ return ( a && +a ) !== ( b && +b ); },\r\n    clone     : function( value ){ return value && new Date( +value ); }\r\n} ).attach( Date );\r\n\r\n// Primitive Types\r\n// ----------------\r\n// Global Mock for missing Integer data type...\r\n// -------------------------------------\r\nInteger = function( x ){ return x ? Math.round( x ) : 0; };\r\n\r\nvar PrimitiveType = attribute.Type.extend( {\r\n    create : function(){ return this.type(); },\r\n\r\n    toJSON : function( value ){ return value; },\r\n    cast   : function( value ){ return value == null ? null : this.type( value ); },\r\n\r\n    isChanged : function( a, b ){ return a !== b; },\r\n\r\n    clone : function( value ){ return value; }\r\n} );\r\n\r\nPrimitiveType.attach( Boolean, String );\r\n\r\nPrimitiveType.extend({\r\n    validate : function( model, value, name ){\r\n        if( value !== value || value === Infinity || value === -Infinity ) return name + ' is invalid number';\r\n    }\r\n} ).attach( Integer, Number );\r\n\r\n// Array Type\r\n// ---------------\r\nattribute.Type.extend( {\r\n    toJSON : function( value ){ return value; },\r\n    cast   : function( value ){\r\n        // Fix incompatible constructor behaviour of Array...\r\n        return value == null || value instanceof Array ? value : [ value ];\r\n    }\r\n} ).attach( Array );\r\n\r\n// Backbone Attribute\r\n// ----------------\r\n\r\n// helper attrSpec mock to force attribute update\r\nvar bbForceUpdateAttr = new ( attribute.Type.extend( {\r\n    isChanged : function(){ return true; }\r\n} ) );\r\n\r\nvar setAttrs      = modelSet.setAttrs,\r\n    setSingleAttr = modelSet.setSingleAttr;\r\n\r\nattribute.Type.extend( {\r\n    create : function( attrs, options ){\r\n        var Type = this.type;\r\n        return Type.create ? Type.create( attrs, options ) : new Type( attrs, options );\r\n    },\r\n    clone  : function( value, options ){ return value && value.clone( options ); },\r\n    toJSON : function( value, name ){\r\n      if( value && value._owner !== this ){\r\n        errors.serializeSharedObject( this, name, value );\r\n      }\r\n\r\n      return value && value.toJSON();\r\n    },\r\n\r\n    isChanged : function( a, b ){ return a !== b; },\r\n\r\n    isBackboneType : true,\r\n    isModel        : true,\r\n\r\n    validate : function( model, value, name ){\r\n        var error = value && value.validationError;\r\n        if( error ) return error;\r\n    },\r\n\r\n    createPropertySpec : function(){\r\n        // if there are nested changes detection enabled, disable optimized setter\r\n        if( this.__events ){\r\n            return (function( self, name, get ){\r\n                return {\r\n                    set : function( value ){\r\n                        var attrs = {};\r\n                        attrs[ name ] = value;\r\n                        setAttrs( this, attrs );\r\n                    },\r\n\r\n                    get : get ? function(){ return get.call( this, this.attributes[ name ], name ); } :\r\n                          function(){ return this.attributes[ name ]; }\r\n                }\r\n            })( this, this.name, this.get );\r\n        }\r\n        else{\r\n            return attribute.Type.prototype.createPropertySpec.call( this );\r\n        }\r\n    },\r\n\r\n    cast : function( value, options, model, name ){\r\n        var incompatibleType          = value != null && !( value instanceof this.type ),\r\n            existingModelOrCollection = model.attributes[ name ];\r\n\r\n        if( incompatibleType ){\r\n            if( existingModelOrCollection ){ // ...delegate update for existing object 'set' method\r\n                if( options && options.parse && this.isModel ){ // handle inconsistent backbone's parse implementation\r\n                    value = existingModelOrCollection.parse( value );\r\n                }\r\n\r\n                existingModelOrCollection.set( value, options );\r\n                value = existingModelOrCollection;\r\n            }\r\n            else{ // ...or create a new object, if it's not exist\r\n                value = this.create( value, options );\r\n            }\r\n        }\r\n\r\n        // handle nested objects ownership\r\n        if( existingModelOrCollection !== value ){\r\n          if( existingModelOrCollection && existingModelOrCollection._owner === model ) existingModelOrCollection._owner = null;\r\n          if( value && !value.collection && !value._owner ) value._owner = model;\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    initialize : function( spec ){\r\n        var name               = this.name,\r\n            triggerWhenChanged = this.triggerWhenChanged || spec.type.prototype.triggerWhenChanged;\r\n\r\n        this.isModel = this.type === Model || this.type.prototype instanceof Model;\r\n\r\n        if( triggerWhenChanged ){\r\n            this.__events = {};\r\n            this.__events[ triggerWhenChanged ] = function handleNestedChange(){\r\n                var attr = this.attributes[ name ];\r\n\r\n                if( this.__duringSet ){\r\n                    this.__nestedChanges[ name ] = attr;\r\n                }\r\n                else{\r\n                    setSingleAttr( this, name, attr, bbForceUpdateAttr );\r\n                }\r\n            };\r\n        }\r\n    }\r\n} ).attach( Model, Collection );\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/metatypes.js\n ** module id = 19\n ** module chunks = 0\n **/","var Backbone   = require( './backbone+' ),\r\n    $          = Backbone.$;\r\n    Model      = require( './model' ),\r\n    Collection = require( './collection' ),\r\n    RestMixin  = require( './rest-mixin' ),\r\n    _          = require( 'underscore' );\r\n\r\nvar _store = null;\r\n\r\nvar Store = exports.Model = Model.extend({\r\n  // end store lookup sequence on this class\r\n  getStore : function(){ return this; },\r\n\r\n  sync : function(){ return RestMixin.sync.apply( Backbone, arguments ); },\r\n  // delegate item lookup to owner, and to the global store if undefined\r\n  get : function( name ){ return this[ name ] || ( this._owner && this._owner.get( name ) ) || _store[ name ]; }\r\n});\r\n\r\nvar RestStore = exports.Lazy = Store.extend( {\r\n    _resolved  : {},\r\n\r\n    initialize   : function(){\r\n        this._resolved = {};\r\n        var self = this;\r\n\r\n        _.each( this.attributes, function( element, name ){\r\n            if( !element ) return;\r\n\r\n            element.store = this;\r\n\r\n            var fetch = element.fetch;\r\n\r\n            if( fetch ){\r\n                element.fetch = function() {\r\n                    return self._resolved[ name ] = fetch.apply( this, arguments );\r\n                }\r\n            }\r\n\r\n            if( element instanceof Collection && element.length ){\r\n                this._resolved[name] = true;\r\n            }\r\n        }, this );\r\n    },\r\n\r\n    // fetch specified items, or all items if called without arguments.\r\n    // returns jquery promise\r\n    fetch : function(){\r\n        var xhr         = [],\r\n            objsToFetch = arguments.length ? arguments : _.keys( this.attributes );\r\n\r\n        _.each( objsToFetch, function( name ){\r\n            var attr = this.attributes[name];\r\n            attr && attr.fetch && xhr.push( attr.fetch() );\r\n        }, this );\r\n\r\n        return $ && $.when && $.when.apply( Backbone.$, xhr );\r\n    },\r\n\r\n    // fetch specified items, or all items if called without arguments.\r\n    // returns first jquery promise.\r\n    fetchOnce : function(){\r\n        var xhr         = [],\r\n            self        = this,\r\n            objsToFetch = arguments.length ? arguments : _.keys( this.attributes );\r\n\r\n        _.each( objsToFetch, function( name ){\r\n            var attr = self.attributes[ name ];\r\n            self._resolved[ name ] || attr && attr.fetch && xhr.push( attr.fetch() );\r\n        }, this );\r\n\r\n        return $ && $.when && $.when.apply( Backbone.$, xhr );\r\n    },\r\n\r\n    clear : function(){\r\n        var objsToClear = arguments.length ? arguments : _.keys( this.attributes );\r\n\r\n        _.each( objsToClear, function( name ){\r\n            var element = this.attributes[ name ];\r\n\r\n            if( element instanceof Collection ){\r\n                element.reset();\r\n            }\r\n            else if( element instanceof Store ){\r\n                element.clear();\r\n            }\r\n            else if( element instanceof Model ){\r\n                element.set( element.defaults() )\r\n            }\r\n\r\n            this._resolved[ name ] = false;\r\n        }, this );\r\n\r\n        return this;\r\n    }\r\n}, {\r\n    extend : function( props, staticProps ){\r\n        var spec = props.defaults || props.attributes;\r\n\r\n        // add automatic fetching on first element's access\r\n        _.each( spec, function( Type, name ){\r\n            Type.options && ( spec[name] = Type.options( {\r\n                get : function( value ){\r\n                    if( !this._resolved[name] ) {\r\n                        value.fetch && value.fetch();\r\n                    }\r\n\r\n                    return value;\r\n                },\r\n\r\n                set : function( value ){\r\n                    value.length || ( this._resolved[name] = false );\r\n                    return value;\r\n                }\r\n            } ) );\r\n        } );\r\n\r\n        return Model.extend.call( this, props, staticProps )\r\n    }\r\n});\r\n\r\n// Exports native property spec for model store\r\nexports.globalProp = {\r\n    get : function(){ return _store; },\r\n\r\n    set : function( store ){\r\n        if( _store ){\r\n          _store.stopListening();\r\n          delete _store.get;\r\n        }\r\n\r\n        Collection.prototype._defaultStore = Model.prototype._defaultStore = _store = store;\r\n        _store.get = Model.prototype.get;\r\n    }\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/store.js\n ** module id = 20\n ** module chunks = 0\n **/"],"sourceRoot":""}